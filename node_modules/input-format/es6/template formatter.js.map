{"version":3,"sources":["../source/template formatter.js"],"names":["count_occurences","close_braces","template_formatter","template","placeholder","should_close_braces","text","value","characters_in_template","value_character_index","filled_in_template","character","length"],"mappings":";AAAA,SAASA,gBAAT,QAAiC,WAAjC;AACA,OAAOC,YAAP,MAAyB,gBAAzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,kBAAT,CAA4BC,QAA5B,EACf;AAAA,KADqDC,WACrD,uEADmE,GACnE;AAAA,KADwEC,mBACxE;;AACC,KAAI,CAACF,QAAL,EACA;AACC,SAAO;AAAA,UAAU,EAAEG,MAAMC,KAAR,EAAV;AAAA,GAAP;AACA;;AAED,KAAMC,yBAAyBR,iBAAiBI,WAAjB,EAA8BD,QAA9B,CAA/B;;AAEA,QAAO,UAASI,KAAT,EACP;AACC,MAAI,CAACA,KAAL,EACA;AACC,UAAO,EAAED,MAAM,EAAR,EAAYH,kBAAZ,EAAP;AACA;;AAED,MAAIM,wBAAwB,CAA5B;AACA,MAAIC,qBAAqB,EAAzB;;AAPD;AAAA;AAAA;;AAAA;AASC,qCAAwBP,QAAxB,4GACA;AAAA,QADWQ,SACX;;AACC,QAAIA,cAAcP,WAAlB,EACA;AACCM,2BAAsBC,SAAtB;AACA;AACA;;AAEDD,0BAAsBH,MAAME,qBAAN,CAAtB;AACAA;;AAEA;AACA;AACA;AACA;AACA,QAAIA,0BAA0BF,MAAMK,MAApC,EACA;AACC;AACA;AACA;AACA,SAAIL,MAAMK,MAAN,GAAeJ,sBAAnB,EACA;AACC;AACA;AACD;AACD;AAlCF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoCC,MAAIH,mBAAJ,EACA;AACCK,wBAAqBT,aAAaS,kBAAb,EAAiCP,QAAjC,CAArB;AACA;;AAED,SAAO,EAAEG,MAAMI,kBAAR,EAA4BP,kBAA5B,EAAP;AACA,EA3CD;AA4CA","file":"template formatter.js","sourcesContent":["import { count_occurences } from './helpers'\nimport close_braces from './close braces'\n\n// Takes a `template` where character placeholders\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\n//\n// Returns a function which takes `value` characters\n// and returns the `template` filled with those characters.\n// If the `template` can only be partially filled\n// then it is cut off.\n//\n// If `should_close_braces` is `true`,\n// then it will also make sure all dangling braces are closed,\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\n//\nexport default function template_formatter(template, placeholder = 'x', should_close_braces)\n{\n\tif (!template)\n\t{\n\t\treturn value => ({ text: value })\n\t}\n\n\tconst characters_in_template = count_occurences(placeholder, template)\n\n\treturn function(value)\n\t{\n\t\tif (!value)\n\t\t{\n\t\t\treturn { text: '', template }\n\t\t}\n\n\t\tlet value_character_index = 0\n\t\tlet filled_in_template = ''\n\n\t\tfor (const character of template)\n\t\t{\n\t\t\tif (character !== placeholder)\n\t\t\t{\n\t\t\t\tfilled_in_template += character\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfilled_in_template += value[value_character_index]\n\t\t\tvalue_character_index++\n\n\t\t\t// If the last available value character has been filled in,\n\t\t\t// then return the filled in template\n\t\t\t// (either trim the right part or retain it,\n\t\t\t//  if no more character placeholders in there)\n\t\t\tif (value_character_index === value.length)\n\t\t\t{\n\t\t\t\t// If there are more character placeholders\n\t\t\t\t// in the right part of the template\n\t\t\t\t// then simply trim it.\n\t\t\t\tif (value.length < characters_in_template)\n\t\t\t\t{\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (should_close_braces)\n\t\t{\n\t\t\tfilled_in_template = close_braces(filled_in_template, template)\n\t\t}\n\n\t\treturn { text: filled_in_template, template }\n\t}\n}"]}