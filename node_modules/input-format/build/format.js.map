{"version":3,"sources":["../source/format.js"],"names":["format","value","caret","formatter","text","template","undefined","length","index","found","possibly_last_input_character_index"],"mappings":";;;;;kBAkCwBA,M;;AAlCxB;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,MAAT,CAAgBC,KAAhB,EAAuBC,KAAvB,EAA8BC,SAA9B,EACf;AACC,KAAI,OAAOA,SAAP,KAAqB,QAAzB,EACA;AACCA,cAAY,iCAAmBA,SAAnB,CAAZ;AACA;;AAJF,YAM0BA,UAAUF,KAAV,KAAoB,EAN9C;AAAA,KAMOG,IANP,QAMOA,IANP;AAAA,KAMaC,QANb,QAMaA,QANb;;AAQC,KAAID,SAASE,SAAb,EACA;AACEF,SAAOH,KAAP;AACD;;AAED,KAAII,QAAJ,EACA;AACC,MAAIH,UAAUI,SAAd,EACA;AACCJ,WAAQE,KAAKG,MAAb;AACA,GAHD,MAKA;AACC,OAAIC,QAAQ,CAAZ;AACA,OAAIC,QAAQ,KAAZ;;AAEA,OAAIC,sCAAsC,CAAC,CAA3C;;AAEA,UAAOF,QAAQJ,KAAKG,MAAb,IAAuBC,QAAQH,SAASE,MAA/C,EACA;AACC;AACA,QAAIH,KAAKI,KAAL,MAAgBH,SAASG,KAAT,CAApB,EACA;AACC,SAAIN,UAAU,CAAd,EACA;AACCO,cAAQ,IAAR;AACAP,cAAQM,KAAR;AACA;AACA;;AAEDE,2CAAsCF,KAAtC;;AAEAN;AACA;;AAEDM;AACA;;AAED;AACA;AACA,OAAI,CAACC,KAAL,EACA;AACCP,YAAQQ,sCAAsC,CAA9C;AACA;AACD;AACD;;AAED,QAAO,EAAEN,UAAF,EAAQF,YAAR,EAAP;AACA","file":"format.js","sourcesContent":["import template_formatter from './template formatter'\n\n// Formats `value` value preserving `caret` at the same character.\n//\n// `{ value, caret }` attribute is the result of `parse()` function call.\n//\n// Returns `{ text, caret }` where the new `caret` is the caret position\n// inside `text` text corresponding to the original `caret` position inside `value`.\n//\n// `formatter(value)` is a function returning `{ text, template }`.\n//\n// `text` is the `value` value formatted using `template`.\n// It may either cut off the non-filled right part of the `template`\n// or it may fill the non-filled character placeholders\n// in the right part of the `template` with `spacer`\n// which is a space (' ') character by default.\n//\n// `template` is the template used to format the `value`.\n// It can be either a full-length template or a partial template.\n//\n// `formatter` can also be a string â€” a `template`\n// where character placeholders are denoted by 'x'es.\n// In this case `formatter` function is automatically created.\n//\n// Example:\n//\n// `value` is '880',\n// `caret` is `2` (before the first `0`)\n//\n// `formatter` is `'880' =>\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\n//\n// The result is `{ text: '8 (80 )', caret: 4 }`.\n//\nexport default function format(value, caret, formatter)\n{\n\tif (typeof formatter === 'string')\n\t{\n\t\tformatter = template_formatter(formatter)\n\t}\n\n\tlet { text, template } = formatter(value) || {}\n\n\tif (text === undefined)\n\t{\n\t\t text = value\n\t}\n\n\tif (template)\n\t{\n\t\tif (caret === undefined)\n\t\t{\n\t\t\tcaret = text.length\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet index = 0\n\t\t\tlet found = false\n\n\t\t\tlet possibly_last_input_character_index = -1\n\n\t\t\twhile (index < text.length && index < template.length)\n\t\t\t{\n\t\t\t\t// Character placeholder found\n\t\t\t\tif (text[index] !== template[index])\n\t\t\t\t{\n\t\t\t\t\tif (caret === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tcaret = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tpossibly_last_input_character_index = index\n\n\t\t\t\t\tcaret--\n\t\t\t\t}\n\n\t\t\t\tindex++\n\t\t\t}\n\n\t\t\t// If the caret was positioned after last input character,\n\t\t\t// then the text caret index is just after the last input character.\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\tcaret = possibly_last_input_character_index + 1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { text, caret }\n}"]}