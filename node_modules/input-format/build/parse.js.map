{"version":3,"sources":["../source/parse.js"],"names":["parse","text","caret_position","parse_character","value","focused_input_character_index","index","length","character","undefined","result","caret"],"mappings":";;;;;kBAmBwBA,K;AAnBxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,KAAT,CAAeC,IAAf,EAAqBC,cAArB,EAAqCC,eAArC,EACf;AACC,KAAIC,QAAQ,EAAZ;;AAEA,KAAIC,gCAAgC,CAApC;;AAEA,KAAIC,QAAQ,CAAZ;AACA,QAAOA,QAAQL,KAAKM,MAApB,EACA;AACC,MAAMC,YAAYL,gBAAgBF,KAAKK,KAAL,CAAhB,EAA6BF,KAA7B,CAAlB;;AAEA,MAAII,cAAcC,SAAlB,EACA;AACCL,YAASI,SAAT;;AAEA,OAAIN,mBAAmBO,SAAvB,EACA;AACC,QAAIP,mBAAmBI,KAAvB,EACA;AACCD,qCAAgCD,MAAMG,MAAN,GAAe,CAA/C;AACA,KAHD,MAIK,IAAIL,iBAAiBI,KAArB,EACL;AACCD,qCAAgCD,MAAMG,MAAtC;AACA;AACA;AACF;;AAEDD;AACA;;AAED;AACA,KAAIJ,mBAAmBO,SAAvB,EACA;AACC;AACAJ,kCAAgCD,MAAMG,MAAtC;AACA;;AAED,KAAMG,SACN;AACCN,cADD;AAECO,SAAQN;AAFT,EADA;;AAMA,QAAOK,MAAP;AACA","file":"parse.js","sourcesContent":["// Parses the `text`.\n//\n// Returns `{ value, caret }` where `caret` is\n// the caret position inside `value`\n// corresponding to the `caret_position` inside `text`.\n//\n// The `text` is parsed by feeding each character sequentially to\n// `parse_character(character, value)` function\n// and appending the result (if it's not `undefined`) to `value`.\n//\n// Example:\n//\n// `text` is `8 (800) 555-35-35`,\n// `caret_position` is `4` (before the first `0`).\n// `parse_character` is `(character, value) =>\n//   if (character >= '0' && character <= '9') { return character }`.\n//\n// then `parse()` outputs `{ value: '88005553535', caret: 2 }`.\n//\nexport default function parse(text, caret_position, parse_character)\n{\n\tlet value = ''\n\n\tlet focused_input_character_index = 0\n\n\tlet index = 0\n\twhile (index < text.length)\n\t{\n\t\tconst character = parse_character(text[index], value)\n\n\t\tif (character !== undefined)\n\t\t{\n\t\t\tvalue += character\n\n\t\t\tif (caret_position !== undefined)\n\t\t\t{\n\t\t\t\tif (caret_position === index)\n\t\t\t\t{\n\t\t\t\t\tfocused_input_character_index = value.length - 1;\n\t\t\t\t}\n\t\t\t\telse if (caret_position > index)\n\t\t\t\t{\n\t\t\t\t\tfocused_input_character_index = value.length\n\t\t\t\t}\n\t\t\t }\n\t\t}\n\n\t\tindex++\n\t}\n\n\t// If caret position wasn't specified\n\tif (caret_position === undefined)\n\t{\n\t\t// Then set caret position to \"after the last input character\"\n\t\tfocused_input_character_index = value.length\n\t}\n\n\tconst result =\n\t{\n\t\tvalue,\n\t\tcaret : focused_input_character_index\n\t}\n\n\treturn result\n}"]}