{"version":3,"sources":["../source/AsYouType.js"],"names":["get_phone_code","get_national_prefix","get_national_prefix_for_parsing","get_formats","get_format_pattern","get_format_format","get_format_international_format","get_format_national_prefix_formatting_rule","get_format_national_prefix_is_mandatory_when_formatting","get_format_leading_digits_patterns","get_format_uses_national_prefix","get_metadata_by_country_phone_code","VALID_PUNCTUATION","PLUS_CHARS","VALID_DIGITS","extract_formatted_phone_number","parse_phone_number","parse_phone_number_and_country_phone_code","find_country_code","strip_national_prefix","FIRST_GROUP_PATTERN","format_national_number_using_format","local_to_international_style","matches_entirely","DUMMY_DIGIT","DUMMY_DIGIT_MATCHER","RegExp","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","DIGIT_PLACEHOLDER_MATCHER_GLOBAL","CHARACTER_CLASS_PATTERN","STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_INCOMPLETE_PHONE_NUMBER","VALID_INCOMPLETE_PHONE_NUMBER_PATTERN","as_you_type","country_code","metadata","countries","Error","default_country","reset","text","extracted_number","indexOf","current_output","process_input","input","parsed_input","reset_countriness","slice","national_number","is_international","country_phone_code","extract_country_phone_code","initialize_phone_number_formats_for_this_country_phone_code","reset_format","determine_the_country","country","previous_national_prefix","national_prefix","extract_national_prefix","matching_formats","available_formats","should_format","format_as_non_formatted_number","match_formats_by_leading_digits","formatted_national_phone_number","format_national_phone_number","full_phone_number","template","length","next_digits","national_number_formatted_with_previous_format","chosen_format","format_next_national_number_digits","formatted_number","attempt_to_format_complete_phone_number","choose_another_format","reformat_national_number","undefined","reset_country","country_metadata","partially_populated_template","last_match_position","filter","format","test","leading_digits","index_of_leading_digits_pattern","leading_digits_pattern_count","leading_digits_pattern_index","Math","min","leading_digits_pattern","matcher","validate_format","create_formatting_template","full_number","replace","formatted_national_number","number","get_template_for_phone_number_format_pattern","national_prefix_formatting_rule","number_pattern","dummy_phone_number_matching_format_pattern","match","number_format","strict_pattern","national_number_dummy_digits","digits","digit","search","close_dangling_braces","cut_before","retained_template","opening_braces","count_occurences","closing_braces","dangling_braces","symbol","string","count","character","times","result"],"mappings":"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","file":"AsYouType.js","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n\r\nimport\r\n{\r\n\tget_phone_code,\r\n\tget_national_prefix,\r\n\tget_national_prefix_for_parsing,\r\n\tget_formats,\r\n\tget_format_pattern,\r\n\tget_format_format,\r\n\tget_format_international_format,\r\n\tget_format_national_prefix_formatting_rule,\r\n\tget_format_national_prefix_is_mandatory_when_formatting,\r\n\tget_format_leading_digits_patterns,\r\n\tget_format_uses_national_prefix,\r\n\tget_metadata_by_country_phone_code\r\n}\r\nfrom './metadata'\r\n\r\nimport\r\n{\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tVALID_DIGITS,\r\n\textract_formatted_phone_number,\r\n\tparse_phone_number,\r\n\tparse_phone_number_and_country_phone_code,\r\n\tfind_country_code,\r\n\tstrip_national_prefix\r\n}\r\nfrom './parse'\r\n\r\nimport\r\n{\r\n\tFIRST_GROUP_PATTERN,\r\n\tformat_national_number_using_format,\r\n\tlocal_to_international_style\r\n}\r\nfrom './format'\r\n\r\nimport\r\n{\r\n\tmatches_entirely\r\n}\r\nfrom './common'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\nconst DUMMY_DIGIT_MATCHER = new RegExp(DUMMY_DIGIT, 'g')\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\nconst DIGIT_PLACEHOLDER_MATCHER_GLOBAL = new RegExp(DIGIT_PLACEHOLDER, 'g')\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CHARACTER_CLASS_PATTERN = /\\[([^\\[\\]])*\\]/g\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst STANDALONE_DIGIT_PATTERN = /\\d(?=[^,}][^,}])/g\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp\r\n(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i')\r\n\r\nexport default class as_you_type\r\n{\r\n\tconstructor(country_code, metadata)\r\n\t{\r\n\t\t// Metadata is required.\r\n\t\tif (!metadata || !metadata.countries)\r\n\t\t{\r\n\t\t\tthrow new Error('Metadata is required')\r\n\t\t}\r\n\r\n\t\tif (country_code && metadata.countries[country_code])\r\n\t\t{\r\n\t\t\tthis.default_country = country_code\r\n\t\t}\r\n\r\n\t\tthis.metadata = metadata\r\n\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tinput(text)\r\n\t{\r\n\t\t// Parse input\r\n\r\n\t\tlet extracted_number = extract_formatted_phone_number(text)\r\n\r\n\t\t// Special case for a lone '+' sign\r\n\t\t// since it's not considered a possible phone number.\r\n\t\tif (!extracted_number)\r\n\t\t{\r\n\t\t\tif (text && text.indexOf('+') >= 0)\r\n\t\t\t{\r\n\t\t\t\textracted_number = '+'\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate possible first part of a phone number\r\n\t\tif (!matches_entirely(extracted_number, VALID_INCOMPLETE_PHONE_NUMBER_PATTERN))\r\n\t\t{\r\n\t\t\treturn this.current_output\r\n\t\t}\r\n\r\n\t\treturn this.process_input(parse_phone_number(extracted_number))\r\n\t}\r\n\r\n\tprocess_input(input)\r\n\t{\r\n\t\t// If an out of position '+' sign detected\r\n\t\t// (or a second '+' sign),\r\n\t\t// then just drop it from the input.\r\n\t\tif (input[0] === '+')\r\n\t\t{\r\n\t\t\tif (!this.parsed_input)\r\n\t\t\t{\r\n\t\t\t\tthis.parsed_input += '+'\r\n\r\n\t\t\t\t// If a default country was set\r\n\t\t\t\t// then reset it because an explicitly international\r\n\t\t\t\t// phone number is being entered\r\n\t\t\t\tthis.reset_countriness()\r\n\t\t\t}\r\n\r\n\t\t\tinput = input.slice(1)\r\n\t\t}\r\n\r\n\t\t// Raw phone number\r\n\t\tthis.parsed_input += input\r\n\r\n\t\t// // Reset phone number validation state\r\n\t\t// this.valid = false\r\n\r\n\t\t// Add digits to the national number\r\n\t\tthis.national_number += input\r\n\r\n\t\t// Try to format the parsed input\r\n\r\n\t\tif (this.is_international())\r\n\t\t{\r\n\t\t\tif (!this.country_phone_code)\r\n\t\t\t{\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then he can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then just return the raw phone number,\r\n\t\t\t\t// because it has no way of knowing\r\n\t\t\t\t// how to format the phone number so far.\r\n\t\t\t\tif (!this.extract_country_phone_code())\r\n\t\t\t\t{\r\n\t\t\t\t\t// Return raw phone number\r\n\t\t\t\t\treturn this.parsed_input\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Initialize country-specific data\r\n\t\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code()\r\n\t\t\t\tthis.reset_format()\r\n\t\t\t\tthis.determine_the_country()\r\n\t\t\t}\r\n\t\t\t// `this.country` could be `undefined`,\r\n\t\t\t// for instance, when there is ambiguity\r\n\t\t\t// in a form of several different countries\r\n\t\t\t// each corresponding to the same country phone code\r\n\t\t\t// (e.g. NANPA: USA, Canada, etc),\r\n\t\t\t// and there's not enough digits entered\r\n\t\t\t// to reliably determine the country\r\n\t\t\t// the phone number belongs to.\r\n\t\t\t// Therefore, in cases of such ambiguity,\r\n\t\t\t// each time something is input,\r\n\t\t\t// try to determine the country\r\n\t\t\t// (if it's not determined yet).\r\n\t\t\telse if (!this.country)\r\n\t\t\t{\r\n\t\t\t\tthis.determine_the_country()\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\r\n\t\t\tconst previous_national_prefix = this.national_prefix\r\n\t\t\tthis.national_number = this.national_prefix + this.national_number\r\n\r\n\t\t\t// Possibly extract a national prefix\r\n\t\t\tthis.extract_national_prefix()\r\n\r\n\t\t\tif (this.national_prefix !== previous_national_prefix)\r\n\t\t\t{\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.matching_formats = this.available_formats\r\n\t\t\t\tthis.reset_format()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!this.should_format())\r\n\t\t{\r\n\t\t\treturn this.format_as_non_formatted_number()\r\n\t\t}\r\n\r\n\t\t// Check the available phone number formats\r\n\t\t// based on the currently available leading digits.\r\n\t\tthis.match_formats_by_leading_digits()\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\tconst formatted_national_phone_number = this.format_national_phone_number(input)\r\n\r\n\t\t// If the phone number could be formatted,\r\n\t\t// then return it, possibly prepending with country phone code\r\n\t\t// (for international phone numbers only)\r\n\t\tif (formatted_national_phone_number)\r\n\t\t{\r\n\t\t\treturn this.full_phone_number(formatted_national_phone_number)\r\n\t\t}\r\n\r\n\t\t// If the phone number couldn't be formatted,\r\n\t\t// then just fall back to the raw phone number.\r\n\t\treturn this.parsed_input\r\n\t}\r\n\r\n\tformat_as_non_formatted_number()\r\n\t{\r\n\t\tif (this.is_international() && this.country_phone_code)\r\n\t\t{\r\n\t\t\tif (this.national_number)\r\n\t\t\t{\r\n\t\t\t\t// For convenience, the public `.template` property\r\n\t\t\t\t// contains the whole international number\r\n\t\t\t\t// if the phone number being input is international:\r\n\t\t\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t\t\t// a spacebar and then the template for the national number digits.\r\n\t\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + repeat(DIGIT_PLACEHOLDER, this.national_number.length)\r\n\r\n\t\t\t\treturn `+${this.country_phone_code} ${this.national_number}`\r\n\t\t\t}\r\n\r\n\t\t\treturn `+${this.country_phone_code}`\r\n\t\t}\r\n\r\n\t\treturn this.parsed_input\r\n\t}\r\n\r\n\tformat_national_phone_number(next_digits)\r\n\t{\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attempt_to_format_complete_phone_number`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tlet national_number_formatted_with_previous_format\r\n\t\tif (this.chosen_format)\r\n\t\t{\r\n\t\t\tnational_number_formatted_with_previous_format = this.format_next_national_number_digits(next_digits)\r\n\t\t}\r\n\r\n\t\t// See if the input digits can be formatted properly already. If not,\r\n\t\t// use the results from format_next_national_number_digits(), which does formatting\r\n\t\t// based on the formatting pattern chosen.\r\n\r\n\t\tconst formatted_number = this.attempt_to_format_complete_phone_number()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone is invalid\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formatted_number)\r\n\t\t{\r\n\t\t\t// if (this.country)\r\n\t\t\t// {\r\n\t\t\t// \tthis.valid = true\r\n\t\t\t// }\r\n\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\r\n\t\t// For some phone number formats national prefix\r\n\r\n\t\t// If the previously chosen phone number format\r\n\t\t// didn't match the next (current) digit being input\r\n\t\t// (leading digits pattern didn't match).\r\n\t\tif (this.choose_another_format())\r\n\t\t{\r\n\t\t\t// And a more appropriate phone number format\r\n\t\t\t// has been chosen for these `leading digits`,\r\n\t\t\t// then format the national phone number (so far)\r\n\t\t\t// using the newly selected phone number pattern.\r\n\r\n\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t// the supplied national number\r\n\t\t\t// using the selected phone number pattern.\r\n\r\n\t\t\treturn this.reformat_national_number()\r\n\t\t}\r\n\r\n\t\t// If could format the next (current) digit\r\n\t\t// using the previously chosen phone number format\r\n\t\t// then return the formatted number so far.\r\n\r\n\t\t// If no new phone number format could be chosen,\r\n\t\t// and couldn't format the supplied national number\r\n\t\t// using the selected phone number pattern,\r\n\t\t// then it will return `undefined`.\r\n\r\n\t\treturn national_number_formatted_with_previous_format\r\n\t}\r\n\r\n\treset()\r\n\t{\r\n\t\t// Input stripped of non-phone-number characters.\r\n\t\t// Can only contain a possible leading '+' sign and digits.\r\n\t\tthis.parsed_input = ''\r\n\r\n\t\tthis.current_output = ''\r\n\r\n\t\t// This contains the national prefix that has been extracted. It contains only\r\n\t\t// digits without formatting.\r\n\t\tthis.national_prefix = ''\r\n\r\n\t\tthis.national_number = ''\r\n\r\n\t\tthis.reset_countriness()\r\n\r\n\t\tthis.reset_format()\r\n\r\n\t\t// this.valid = false\r\n\r\n\t\treturn this\r\n\t}\r\n\r\n\treset_country()\r\n\t{\r\n\t\tif (this.default_country && !this.is_international())\r\n\t\t{\r\n\t\t\tthis.country = this.default_country\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.country = undefined\r\n\t\t}\r\n\t}\r\n\r\n\treset_countriness()\r\n\t{\r\n\t\tthis.reset_country()\r\n\r\n\t\tif (this.default_country && !this.is_international())\r\n\t\t{\r\n\t\t\tthis.country_metadata = this.metadata.countries[this.default_country]\r\n\t\t\tthis.country_phone_code = get_phone_code(this.country_metadata)\r\n\r\n\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code()\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.country_metadata = undefined\r\n\t\t\tthis.country_phone_code = undefined\r\n\r\n\t\t\tthis.available_formats = []\r\n\t\t\tthis.matching_formats = this.available_formats\r\n\t\t}\r\n\t}\r\n\r\n\treset_format()\r\n\t{\r\n\t\tthis.chosen_format = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.partially_populated_template = undefined\r\n\t\tthis.last_match_position = -1\r\n\t}\r\n\r\n\t// Format each digit of national phone number (so far)\r\n\t// using the newly selected phone number pattern.\r\n\treformat_national_number()\r\n\t{\r\n\t\t// Format each digit of national phone number (so far)\r\n\t\t// using the selected phone number pattern.\r\n\t\treturn this.format_next_national_number_digits(this.national_number)\r\n\t}\r\n\r\n\tinitialize_phone_number_formats_for_this_country_phone_code()\r\n\t{\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.available_formats = get_formats(this.country_metadata).filter((format) =>\r\n\t\t{\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(get_format_international_format(format))\r\n\t\t})\r\n\r\n\t\tthis.matching_formats = this.available_formats\r\n\t}\r\n\r\n\tmatch_formats_by_leading_digits()\r\n\t{\r\n\t\tconst leading_digits = this.national_number\r\n\r\n\t\t// \"leading digits\" pattern list starts with\r\n\t\t// one of a maximum length of 3 digits,\r\n\t\t// and then with each additional digit\r\n\t\t// a more precise \"leading digits\" pattern is specified.\r\n\r\n\t\tlet index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH\r\n\r\n\t\tif (index_of_leading_digits_pattern < 0)\r\n\t\t{\r\n\t\t\tindex_of_leading_digits_pattern = 0\r\n\t\t}\r\n\r\n\t\tthis.matching_formats = this.matching_formats.filter((format) =>\r\n\t\t{\r\n\t\t\tconst leading_digits_pattern_count = get_format_leading_digits_patterns(format).length\r\n\r\n\t\t\t// Keep everything that isn't restricted by leading digits.\r\n\t\t\tif (leading_digits_pattern_count === 0)\r\n\t\t\t{\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\r\n\t\t\tconst leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_pattern_count - 1)\r\n\t\t\tconst leading_digits_pattern = get_format_leading_digits_patterns(format)[leading_digits_pattern_index]\r\n\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leading_digits_pattern})`).test(leading_digits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\tif (this.chosen_format && this.matching_formats.indexOf(this.chosen_format) === -1)\r\n\t\t{\r\n\t\t\tthis.reset_format()\r\n\t\t}\r\n\t}\r\n\r\n\tshould_format()\r\n\t{\r\n\t\t// Start matching any formats at all when the national number\r\n\t\t// entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives\r\n\t\t// like when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Google could have provided leading digits patterns starting\r\n\t\t// with a single digit but they chose not to (for whatever reasons).\r\n\t\t//\r\n\t\treturn this.national_number >= MIN_LEADING_DIGITS_LENGTH\r\n\t}\r\n\r\n\t// Check to see if there is an exact pattern match for these digits. If so, we\r\n\t// should use this instead of any other formatting template whose\r\n\t// leadingDigitsPattern also matches the input.\r\n\tattempt_to_format_complete_phone_number()\r\n\t{\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\tconst matcher = new RegExp('^(?:' + get_format_pattern(format) + ')$')\r\n\r\n\t\t\tif (!matcher.test(this.national_number))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.validate_format(format))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.reset_format()\r\n\t\t\tthis.chosen_format = format\r\n\r\n\t\t\tconst formatted_number = format_national_number_using_format\r\n\t\t\t(\r\n\t\t\t\tthis.national_number,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.is_international(),\r\n\t\t\t\tthis.national_prefix.length > 0,\r\n\t\t\t\tthis.country_metadata\r\n\t\t\t)\r\n\r\n\t\t\t// Set `this.template` and `this.partially_populated_template`.\r\n\t\t\t//\r\n\t\t\t// `else` case doesn't ever happen\r\n\t\t\t// with the current metadata,\r\n\t\t\t// but just in case.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.create_formatting_template(format))\r\n\t\t\t{\r\n\t\t\t\t// Populate `this.partially_populated_template`\r\n\t\t\t\tthis.reformat_national_number()\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Prepend `+CountryCode` in case of an international phone number\r\n\t\t\t\tconst full_number = this.full_phone_number(formatted_number)\r\n\t\t\t\tthis.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.partially_populated_template = full_number\r\n\t\t\t}\r\n\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode` in case of an international phone number\r\n\tfull_phone_number(formatted_national_number)\r\n\t{\r\n\t\tif (this.is_international())\r\n\t\t{\r\n\t\t\treturn `+${this.country_phone_code} ${formatted_national_number}`\r\n\t\t}\r\n\r\n\t\treturn formatted_national_number\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textract_country_phone_code()\r\n\t{\r\n\t\tif (!this.national_number)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst { country_phone_code, number } = parse_phone_number_and_country_phone_code(this.parsed_input, this.metadata)\r\n\r\n\t\tif (!country_phone_code)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.country_phone_code = country_phone_code\r\n\t\tthis.national_number = number\r\n\r\n\t\treturn this.country_metadata = get_metadata_by_country_phone_code(country_phone_code, this.metadata)\r\n\t}\r\n\r\n\textract_national_prefix()\r\n\t{\r\n\t\tthis.national_prefix = ''\r\n\r\n\t\tif (!this.country_metadata)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst national_number = strip_national_prefix(this.national_number, this.country_metadata)\r\n\r\n\t\tif (national_number !== this.national_number)\r\n\t\t{\r\n\t\t\tthis.national_prefix = this.national_number.slice(0, this.national_number.length - national_number.length)\r\n\t\t\tthis.national_number = national_number\r\n\t\t}\r\n\r\n\t\treturn this.national_prefix\r\n\t}\r\n\r\n\tchoose_another_format()\r\n\t{\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosen_format === format)\r\n\t\t\t{\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// If this `format` is suitable for \"as you type\",\r\n\t\t\t// then extract the template from this format\r\n\t\t\t// and use it to format the phone number being input.\r\n\r\n\t\t\tif (!this.validate_format(format))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.create_formatting_template(format))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tthis.chosen_format = format\r\n\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.last_match_position = -1\r\n\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// No format matches the phone number,\r\n\t\t// therefore set `country` to `undefined`\r\n\t\t// (or to the default country).\r\n\t\tthis.reset_country()\r\n\r\n\t\t// No format matches the national phone number entered\r\n\t\tthis.reset_format()\r\n\t}\r\n\r\n\tvalidate_format(format)\r\n\t{\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and the user didn't input the national prefix,\r\n\t\t// then this phone number format isn't suitable.\r\n\t\tif (!this.is_international() && !this.national_prefix && get_format_national_prefix_is_mandatory_when_formatting(format, this.country_metadata))\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\treturn true\r\n\t}\r\n\r\n\tcreate_formatting_template(format)\r\n\t{\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (get_format_pattern(format).indexOf('|') >= 0)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.get_template_for_phone_number_format_pattern(format)\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// This one is for national number only\r\n\t\tthis.partially_populated_template = template\r\n\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.is_international())\r\n\t\t{\r\n\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + template\r\n\t\t}\r\n\t\t// For local numbers, replace national prefix\r\n\t\t// with a digit placeholder.\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\r\n\t\t// This one is for the full phone number\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t// Generates formatting template for a phone number format\r\n\tget_template_for_phone_number_format_pattern(format)\r\n\t{\r\n\t\tconst national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata)\r\n\r\n\t\t// A very smart trick by the guys at Google\r\n\t\tconst number_pattern = get_format_pattern(format)\r\n\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t.replace(CHARACTER_CLASS_PATTERN, '\\\\d')\r\n\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t.replace(STANDALONE_DIGIT_PATTERN, '\\\\d')\r\n\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\tlet dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.national_number.length > dummy_phone_number_matching_format_pattern.length)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Prepare the phone number format\r\n\t\tconst number_format = this.get_format_format(format, national_prefix_formatting_rule)\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strict_pattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strict_pattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.national_number : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// number_format : `$1 $2 $3`\r\n\t\t// dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `number_pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.national_number` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then `this.national_number` is used\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\r\n\t\tconst strict_pattern = new RegExp('^' + number_pattern + '$')\r\n\t\tconst national_number_dummy_digits = this.national_number.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.national_number` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then use it\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\t\tif (strict_pattern.test(national_number_dummy_digits))\r\n\t\t{\r\n\t\t\tdummy_phone_number_matching_format_pattern = national_number_dummy_digits\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format\r\n\t\treturn dummy_phone_number_matching_format_pattern\r\n\t\t\t// Format the dummy phone number according to the format\r\n\t\t\t.replace(new RegExp(number_pattern), number_format)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER\r\n\t\t\t.replace(DUMMY_DIGIT_MATCHER, DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\tformat_next_national_number_digits(digits)\r\n\t{\r\n\t\tfor (let digit of digits)\r\n\t\t{\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\r\n\t\t\t// If more digits are entered than the current format could handle\r\n\t\t\tif (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1)\r\n\t\t\t{\r\n\t\t\t\t// Reset the current format,\r\n\t\t\t\t// so that the new format will be chosen\r\n\t\t\t\t// in a subsequent `this.choose_another_format()` call\r\n\t\t\t\t// later in code.\r\n\t\t\t\tthis.chosen_format = undefined\r\n\t\t\t\tthis.template = undefined\r\n\t\t\t\tthis.partially_populated_template = undefined\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far\r\n\t\treturn close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\r\n\t\t\t.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')\r\n\t}\r\n\r\n\tis_international()\r\n\t{\r\n\t\treturn this.parsed_input && this.parsed_input[0] === '+'\r\n\t}\r\n\r\n\tget_format_format(format, national_prefix_formatting_rule)\r\n\t{\r\n\t\tlet number_format = this.is_international() ? get_format_international_format(format) : get_format_format(format)\r\n\r\n\t\t// If national prefix formatting rule is set\r\n\t\t// for this phone number format\r\n\t\tif (national_prefix_formatting_rule)\r\n\t\t{\r\n\t\t\t// If the user did input the national prefix\r\n\t\t\t// (or if the national prefix formatting rule does not require national prefix)\r\n\t\t\t// then maybe make it part of the phone number template\r\n\t\t\tif (this.national_prefix || !get_format_uses_national_prefix(national_prefix_formatting_rule))\r\n\t\t\t{\r\n\t\t\t\t// Make the national prefix part of the phone number template\r\n\t\t\t\tnumber_format = number_format.replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.is_international())\r\n\t\t{\r\n\t\t\treturn local_to_international_style(number_format)\r\n\t\t}\r\n\r\n\t\treturn number_format\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermine_the_country()\r\n\t{\r\n\t\tthis.country = find_country_code(this.country_phone_code, this.national_number, this.metadata)\r\n\t}\r\n}\r\n\r\nexport function close_dangling_braces(template, cut_before)\r\n{\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\r\n\tconst opening_braces = count_occurences('(', retained_template)\r\n\tconst closing_braces = count_occurences(')', retained_template)\r\n\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\r\n\twhile (dangling_braces > 0 && cut_before < template.length)\r\n\t{\r\n\t\tif (template[cut_before] === ')')\r\n\t\t{\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string\r\nexport function count_occurences(symbol, string)\r\n{\r\n\tlet count = 0\r\n\r\n\tfor (let character of string)\r\n\t{\r\n\t\tif (character === symbol)\r\n\t\t{\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times)\r\n{\r\n\tif (times < 1)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\tlet result = ''\r\n\r\n\twhile (times > 1)\r\n\t{\r\n\t\tif (times & 1)\r\n\t\t{\r\n\t\t\tresult += string\r\n\t\t}\r\n\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\r\n\treturn result + string\r\n}"]}