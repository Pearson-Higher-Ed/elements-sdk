{"version":3,"sources":["../source/parse.js"],"names":["parse","normalize","replace_characters","is_viable_phone_number","extract_formatted_phone_number","parse_phone_number","parse_phone_number_and_country_phone_code","strip_national_prefix","find_country_code","MAX_LENGTH_COUNTRY_CODE","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","PLUS_CHARS","VALID_DIGITS","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_PUNCTUATION","CAPTURING_EXTN_DIGITS","RFC3966_EXTN_PREFIX","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","LEADING_PLUS_CHARS_PATTERN","DIGIT_MAPPINGS","default_options","country","arg_1","arg_2","arg_3","sort_out_arguments","text","options","metadata","default","countries","Error","restrict","formatted_phone_number","extension","indexOf","split","part","name","value","with_extension_stripped","strip_extension","number","country_phone_code","country_metadata","is_international","national_number","did_have_national_prefix","length","national_number_rule","result","phone","ext","replacements","replaced","character","replacement","toUpperCase","undefined","starts_at","search","slice","replace","test","i","country_phone_code_to_countries","national_prefix_for_parsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","any_groups_were_captured","national_prefix_transform_rule","national_phone_number","possible_countries","country_code","String","start","number_without_extension","matches","match"],"mappings":";;;;;;;;;;;;;;;;;;;kBAqPwBA,K;QAsNRC,S,GAAAA,S;QAOAC,kB,GAAAA,kB;QAwBAC,sB,GAAAA,sB;QAMAC,8B,GAAAA,8B;QAwBAC,kB,GAAAA,kB;QA2BAC,yC,GAAAA,yC;QAmDAC,qB,GAAAA,qB;QAuEAC,iB,GAAAA,iB;;AAxpBhB;;AAEA;;AAaA;;AAMA;;;;;;AAEA;AA5BA;AACA;AACA;AACA;;AA0BA,IAAMC,0BAA0B,CAAhC;;AAEA;AACA,IAAMC,qBAAqB,CAA3B;;AAEA;AACA;AACA,IAAMC,qBAAqB,EAA3B;;AAEA;AACA;AACA,IAAMC,0BAA0B,GAAhC;;AAEO,IAAMC,kCAAa,SAAnB;;AAEP;AACA;AACO,IAAMC,sCAAe,4CAArB;;AAEP;AACA,IAAMC,SAAS,kCAAf;AACA,IAAMC,UAAU,SAAhB;AACA,IAAMC,OAAO,SAAb;AACA,IAAMC,aAAa,6BAAnB;AACA,IAAMC,WAAW,kCAAjB;AACA,IAAMC,SAAS,qBAAf;;AAEA;AACA;AACA;AACA;AACO,IAAMC,qDAAuBN,MAAvB,GAAgCC,OAAhC,GAA0CC,IAA1C,GAAiDC,UAAjD,GAA8DC,QAA9D,GAAyEC,MAA/E;;AAEP;AACA;AACA,IAAME,wBAAwB,OAAOR,YAAP,GAAsB,SAApD;;AAEA;AACA,IAAMS,sBAAsB,OAA5B;;AAEA;;;;;;;;;;;;;;;AAeA,IAAMC,4BACLD,sBACAD,qBADA,GACwB,GADxB,GAEA,cAFA,GAGA,iEAHA,GAIA,yDAJA,GAKA,4BALA,GAMAA,qBANA,GAMwB,KANxB,GAOA,SAPA,GAOYR,YAPZ,GAO2B,UAR5B;;AAUA;AACA;AACA,IAAMW,eAAe,IAAIC,MAAJ,CAAW,QAAQF,yBAAR,GAAoC,IAA/C,EAAqD,GAArD,CAArB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMG,kCAAkC,MAAMb,YAAN,GAAqB,IAArB,GAA4BJ,kBAA5B,GAAiD,GAAzF;AACA;AACA;AACA;AACA;AACA,IAAMkB,qBACJ,MAAMf,UAAN,GAAmB,QAAnB,GACA,KADA,GAEC,GAFD,GAEOQ,iBAFP,GAE2B,IAF3B,GAGC,GAHD,GAGOP,YAHP,GAGsB,GAHtB,GAIA,OAJA,GAKA,GALA,GAMCO,iBAND,GAOCP,YAPD,GAQA,IATF;;AAWA;AACA;AACA,IAAMe,6BAA6B,IAAIH,MAAJ;AAElC;AACA,MACCC,+BADD,GAEA,GAFA,GAGA,GAHA;AAIA;AACA,GALA,GAMCC,kBAND;AAOC;AACA,KARD,GAQSJ,yBART,GAQqC,IARrC,GASA,GAZkC,EAcnC,GAdmC,CAAnC;;AAgBA;AACA,IAAMM,6BAA6B,IAAIJ,MAAJ,CAAW,MAAMb,UAAN,GAAmBC,YAAnB,GAAkC,GAA7C,CAAnC;;AAEA;AACA,IAAMiB,iCAAiC,IAAIL,MAAJ,CAAW,OAAOZ,YAAP,GAAsB,KAAjC,CAAvC;;AAEA,IAAMkB,6BAA6B,IAAIN,MAAJ,CAAW,OAAOb,UAAP,GAAoB,IAA/B,CAAnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,IAAMoB,0CACb;AACC,MAAK,GADN;AAEC,MAAK,GAFN;AAGC,MAAK,GAHN;AAIC,MAAK,GAJN;AAKC,MAAK,GALN;AAMC,MAAK,GANN;AAOC,MAAK,GAPN;AAQC,MAAK,GARN;AASC,MAAK,GATN;AAUC,MAAK,GAVN;AAWC,WAAU,GAXX,EAWgB;AACf,WAAU,GAZX,EAYgB;AACf,WAAU,GAbX,EAagB;AACf,WAAU,GAdX,EAcgB;AACf,WAAU,GAfX,EAegB;AACf,WAAU,GAhBX,EAgBgB;AACf,WAAU,GAjBX,EAiBgB;AACf,WAAU,GAlBX,EAkBgB;AACf,WAAU,GAnBX,EAmBgB;AACf,WAAU,GApBX,EAoBgB;AACf,WAAU,GArBX,EAqBgB;AACf,WAAU,GAtBX,EAsBgB;AACf,WAAU,GAvBX,EAuBgB;AACf,WAAU,GAxBX,EAwBgB;AACf,WAAU,GAzBX,EAyBgB;AACf,WAAU,GA1BX,EA0BgB;AACf,WAAU,GA3BX,EA2BgB;AACf,WAAU,GA5BX,EA4BgB;AACf,WAAU,GA7BX,EA6BgB;AACf,WAAU,GA9BX,EA8BgB;AACf,WAAU,GA/BX,EA+BgB;AACf,WAAU,GAhCX,EAgCgB;AACf,WAAU,GAjCX,EAiCgB;AACf,WAAU,GAlCX,EAkCgB;AACf,WAAU,GAnCX,EAmCgB;AACf,WAAU,GApCX,EAoCgB;AACf,WAAU,GArCX,EAqCgB;AACf,WAAU,GAtCX,EAsCgB;AACf,WAAU,GAvCX,EAuCgB;AACf,WAAU,GAxCX,CAwCgB;AAxChB,CADO;;AA4CP,IAAMC,kBACN;AACCC,UAAS;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA,CADA,CA+Be,SAASnC,KAAT,CAAeoC,KAAf,EAAsBC,KAAtB,EAA6BC,KAA7B,EACf;AAAA,2BACmCC,mBAAmBH,KAAnB,EAA0BC,KAA1B,EAAiCC,KAAjC,CADnC;AAAA,KACOE,IADP,uBACOA,IADP;AAAA,KACaC,OADb,uBACaA,OADb;AAAA,KACsBC,QADtB,uBACsBA,QADtB;;AAGC;;AAEA;;;AACA,KAAID,QAAQN,OAAR,CAAgBQ,OAAhB,IAA2B,CAACD,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBQ,OAAnC,CAAhC,EACA;AACC,QAAM,IAAIE,KAAJ,4BAAmCJ,QAAQN,OAAR,CAAgBQ,OAAnD,CAAN;AACA;;AAED;AACA,KAAIF,QAAQN,OAAR,CAAgBW,QAAhB,IAA4B,CAACJ,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBW,QAAnC,CAAjC,EACA;AACC,QAAM,IAAID,KAAJ,4BAAmCJ,QAAQN,OAAR,CAAgBW,QAAnD,CAAN;AACA;;AAED;;AAEA,KAAIC,+BAAJ;AACA,KAAIC,kBAAJ;;AAEA;AACA,KAAIR,QAAQA,KAAKS,OAAL,CAAa,MAAb,MAAyB,CAArC,EACA;AAAA;AAAA;AAAA;;AAAA;AACC,mDAAmBT,KAAKU,KAAL,CAAW,GAAX,CAAnB,4GACA;AAAA,QADWC,IACX;;AAAA,sBACuBA,KAAKD,KAAL,CAAW,GAAX,CADvB;AAAA;AAAA,QACQE,IADR;AAAA,QACcC,KADd;;AAEC,YAAQD,IAAR;AAEC,UAAK,KAAL;AACCL,+BAAyBM,KAAzB;AACA;AACD,UAAK,KAAL;AACCL,kBAAYK,KAAZ;AACA;AACD,UAAK,eAAL;AACC;AACA,UAAIA,MAAM,CAAN,MAAa,GAAjB,EACA;AACCN,gCAAyBM,QAAQN,sBAAjC;AACA;AACD;AAdF;AAgBA;AApBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBC,EAtBD,MAwBA;AACCA,2BAAyB3C,+BAA+BoC,IAA/B,CAAzB;AACA;;AAED;AACA,KAAI,CAACrC,uBAAuB4C,sBAAvB,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMO,0BAA0BC,gBAAgBR,sBAAhB,CAAhC;;AAEA,KAAIO,wBAAwBN,SAA5B,EACA;AACCD,2BAAyBO,wBAAwBE,MAAjD,EACAR,YAAyBM,wBAAwBN,SADjD;AAEA;;AAjEF,6BAmEsC1C,0CAA0CyC,sBAA1C,EAAkEL,QAAlE,CAnEtC;AAAA,KAmEOe,kBAnEP,yBAmEOA,kBAnEP;AAAA,KAmE2BD,MAnE3B,yBAmE2BA,MAnE3B;;AAqEC;;;AACA,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAIrB,gBAAJ;AACA,KAAIuB,yBAAJ;;AAEA;AACA,KAAIC,mBAAmB,KAAvB;;AAEA,KAAIF,kBAAJ,EACA;AACCE,qBAAmB,IAAnB;;AAEA;AACA,MAAIlB,QAAQN,OAAR,CAAgBW,QAAhB,IACHW,uBAAuB,8BAAef,SAASE,SAAT,CAAmBH,QAAQN,OAAR,CAAgBW,QAAnC,CAAf,CADxB,EAEA;AACC,UAAO,EAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACAY,qBAAmB,kDAAmCD,kBAAnC,EAAuDf,QAAvD,CAAnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAzBD,MA0BK,IAAID,QAAQN,OAAR,CAAgBW,QAAhB,IAA4BL,QAAQN,OAAR,CAAgBQ,OAAhD,EACL;AACCR,YAAUM,QAAQN,OAAR,CAAgBW,QAAhB,IAA4BL,QAAQN,OAAR,CAAgBQ,OAAtD;AACAe,qBAAmBhB,SAASE,SAAT,CAAmBT,OAAnB,CAAnB;;AAEAqB,WAASvD,UAAU8C,sBAAV,CAAT;AACA;;AAED,KAAI,CAACW,gBAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAIE,kBAAkBJ,MAAtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAACG,gBAAL,EACA;AACCC,oBAAkBrD,sBAAsBiD,MAAtB,EAA8BE,gBAA9B,CAAlB;AACA;;AAED,KAAMG,2BAA2BD,oBAAoBJ,MAArD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAACrB,OAAL,EACA;AACC;AACA;AACA;AACAA,YAAU3B,kBAAkBiD,kBAAlB,EAAsCG,eAAtC,EAAuDlB,QAAvD,CAAV;;AAEA;AACA;AACA;AACA,MAAI,CAACP,OAAL,EACA;AACC,UAAO,EAAP;AACA;;AAED;AACAuB,qBAAmBhB,SAASE,SAAT,CAAmBT,OAAnB,CAAnB;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAIyB,gBAAgBE,MAAhB,GAAyBnD,kBAA7B,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMoD,uBAAuB,IAAIrC,MAAJ,CAAW,2CAA4BgC,gBAA5B,CAAX,CAA7B;;AAEA;AACA,KAAI,CAAC,8BAAiBE,eAAjB,EAAkCG,oBAAlC,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAMC,SACN;AACC7B,kBADD;AAEC8B,SAAOL;AAFR,EADA;;AAMA,KAAIZ,SAAJ,EACA;AACCgB,SAAOE,GAAP,GAAalB,SAAb;AACA;;AAED,QAAOgB,MAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAAS/D,SAAT,CAAmBuD,MAAnB,EACP;AACC,QAAOtD,mBAAmBsD,MAAnB,EAA2BvB,cAA3B,CAAP;AACA;;AAED;AACA;AACO,SAAS/B,kBAAT,CAA4BsC,IAA5B,EAAkC2B,YAAlC,EACP;AACC,KAAIC,WAAW,EAAf;;AADD;AAAA;AAAA;;AAAA;AAGC,mDAAwB5B,IAAxB,iHACA;AAAA,OADW6B,SACX;;AACC,OAAMC,cAAcH,aAAaE,UAAUE,WAAV,EAAb,CAApB;;AAEA,OAAID,gBAAgBE,SAApB,EACA;AACCJ,gBAAYE,WAAZ;AACA;AACD;AAXF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaC,QAAOF,QAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASjE,sBAAT,CAAgCqD,MAAhC,EACP;AACC,QAAOA,OAAOM,MAAP,IAAiBpD,kBAAjB,IACN,8BAAiB8C,MAAjB,EAAyB3B,0BAAzB,CADD;AAEA;;AAEM,SAASzB,8BAAT,CAAwCoC,IAAxC,EACP;AACC,KAAI,CAACA,IAAD,IAASA,KAAKsB,MAAL,GAAclD,uBAA3B,EACA;AACC,SAAO,EAAP;AACA;;AAED;;AAEA,KAAM6D,YAAYjC,KAAKkC,MAAL,CAAY5C,0BAAZ,CAAlB;;AAEA,KAAI2C,YAAY,CAAhB,EACA;AACC,SAAO,EAAP;AACA;;AAED,QAAOjC;AACN;AADM,EAELmC,KAFK,CAECF,SAFD;AAGN;AAHM,EAILG,OAJK,CAIG7C,8BAJH,EAImC,EAJnC,CAAP;AAKA;;AAED;AACO,SAAS1B,kBAAT,CAA4BmD,MAA5B,EACP;AACC,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAMG,mBAAmB3B,2BAA2B6C,IAA3B,CAAgCrB,MAAhC,CAAzB;;AAEA;AACA;AACAA,UAASvD,UAAUuD,MAAV,CAAT;;AAEA,KAAIG,gBAAJ,EACA;AACC,eAAWH,MAAX;AACA;;AAED,QAAOA,MAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAASlD,yCAAT,CAAmDkD,MAAnD,EAA2Dd,QAA3D,EACP;AACCc,UAASnD,mBAAmBmD,MAAnB,CAAT;;AAEA,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAIA,OAAO,CAAP,MAAc,GAAlB,EACA;AACC,SAAO,EAAEA,cAAF,EAAP;AACA;;AAED;AACAA,UAASA,OAAOmB,KAAP,CAAa,CAAb,CAAT;;AAEA;AACA,KAAInB,OAAO,CAAP,MAAc,GAAlB,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAIsB,IAAI,CAAR;AACA,QAAOA,KAAKrE,uBAAL,IAAgCqE,KAAKtB,OAAOM,MAAnD,EACA;AACC,MAAML,qBAAqBD,OAAOmB,KAAP,CAAa,CAAb,EAAgBG,CAAhB,CAA3B;;AAEA,MAAIpC,SAASqC,+BAAT,CAAyCtB,kBAAzC,CAAJ,EACA;AACC,UAAO,EAAEA,sCAAF,EAAsBD,QAAQA,OAAOmB,KAAP,CAAaG,CAAb,CAA9B,EAAP;AACA;;AAEDA;AACA;;AAED,QAAO,EAAP;AACA;;AAED;AACO,SAASvE,qBAAT,CAA+BiD,MAA/B,EAAuCE,gBAAvC,EACP;AACC,KAAMsB,8BAA8B,+CAAgCtB,gBAAhC,CAApC;;AAEA,KAAI,CAACF,MAAD,IAAW,CAACwB,2BAAhB,EACA;AACC,SAAOxB,MAAP;AACA;;AAED;AACA,KAAMyB,0BAA0B,IAAIvD,MAAJ,CAAW,SAASsD,2BAAT,GAAuC,GAAlD,CAAhC;AACA,KAAME,0BAA0BD,wBAAwBE,IAAxB,CAA6B3B,MAA7B,CAAhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAAC0B,uBAAL,EACA;AACC,SAAO1B,MAAP;AACA;;AAGD,KAAI4B,oCAAJ;;AAEA;AACA;AACA,KAAMC,2BAA2BH,wBAAwBA,wBAAwBpB,MAAxB,GAAiC,CAAzD,CAAjC;AACA,KAAMwB,iCAAiC,kDAAmC5B,gBAAnC,CAAvC;;AAEA;AACA,KAAI4B,kCAAkCD,wBAAtC,EACA;AACCD,gCAA8B5B,OAAOoB,OAAP,CAAeK,uBAAf,EAAwCK,8BAAxC,CAA9B;AACA;AACD;AACA;AALA,MAOA;AACCF,iCAA8B5B,OAAOmB,KAAP,CAAaO,wBAAwB,CAAxB,EAA2BpB,MAAxC,CAA9B;AACA;;AAED;AACA,KAAMC,uBAAuB,IAAIrC,MAAJ,CAAW,2CAA4BgC,gBAA5B,CAAX,CAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,8BAAiBF,MAAjB,EAAyBO,oBAAzB,KACF,CAAC,8BAAiBqB,2BAAjB,EAA8CrB,oBAA9C,CADH,EAEA;AACC,SAAOP,MAAP;AACA;;AAED;AACE,QAAO4B,2BAAP;AACF;;AAEM,SAAS5E,iBAAT,CAA2BiD,kBAA3B,EAA+C8B,qBAA/C,EAAsE7C,QAAtE,EACP;AACC;AACA,KAAM8C,qBAAqB9C,SAASqC,+BAAT,CAAyCtB,kBAAzC,CAA3B;;AAEA;AACA;AACA,KAAI+B,mBAAmB1B,MAAnB,KAA8B,CAAlC,EACA;AACC,SAAO0B,mBAAmB,CAAnB,CAAP;AACA;;AATF;AAAA;AAAA;;AAAA;AAWC,mDAAyBA,kBAAzB,iHACA;AAAA,OADSC,YACT;;AACC,OAAMtD,UAAUO,SAASE,SAAT,CAAmB6C,YAAnB,CAAhB;;AAEA;AACA,OAAI,kCAAmBtD,OAAnB,CAAJ,EACA;AACC,QAAIoD,yBACHA,sBAAsBb,MAAtB,CAA6B,kCAAmBvC,OAAnB,CAA7B,MAA8D,CAD/D,EAEA;AACC,YAAOsD,YAAP;AACA;AACD;AACD;AACA;AATA,QAUK,IAAI,qBAAgB,EAAExB,OAAOsB,qBAAT,EAAgCpD,SAASsD,YAAzC,EAAhB,EAAyE/C,QAAzE,CAAJ,EACL;AACC,YAAO+C,YAAP;AACA;AACD;AA9BF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASlD,kBAAT,CAA4BH,KAA5B,EAAmCC,KAAnC,EAA0CC,KAA1C,EACA;AACC,KAAIE,aAAJ;AACA,KAAIC,gBAAJ;AACA,KAAIC,iBAAJ;;AAEA;AACA;AACA;AACA,KAAI,OAAON,KAAP,KAAiB,QAArB,EACA;AACCA,UAAQsD,OAAOtD,KAAP,CAAR;AACA;;AAED;AACA;AACA,KAAI,OAAOA,KAAP,KAAiB,QAArB,EACA;AACCI,SAAOJ,KAAP;AACA;;AAED;AACA;AACA;AACA,KAAI,OAAOC,KAAP,KAAiB,QAArB,EACA;AACCI,YAAU,EAAEN,SAAS,EAAEW,UAAUT,KAAZ,EAAX,EAAV;AACAK,aAAWJ,KAAX;AACA;AACD;AACA;AACA;AAPA,MASA;AACC,OAAIA,KAAJ,EACA;AACCG,cAAWJ,KAAX;AACAK,eAAWJ,KAAX;AACA,IAJD,MAMA;AACCI,eAAWL,KAAX;AACA;AACD;;AAED;AACA,KAAI,CAACK,QAAD,IAAa,CAACA,SAASE,SAA3B,EACA;AACC,QAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;AACA;;AAED;AACA,KAAIJ,OAAJ,EACA;AACCA,uCAAeP,eAAf,EAAmCO,OAAnC;AACA,EAHD,MAKA;AACCA,YAAUP,eAAV;AACA;;AAED,QAAO,EAAEM,UAAF,EAAQC,gBAAR,EAAiBC,kBAAjB,EAAP;AACA;;AAED;AACA;AACA;AACA,SAASa,eAAT,CAAyBC,MAAzB,EACA;AACC,KAAMmC,QAAQnC,OAAOkB,MAAP,CAAcjD,YAAd,CAAd;AACA,KAAIkE,QAAQ,CAAZ,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMC,2BAA2BpC,OAAOmB,KAAP,CAAa,CAAb,EAAgBgB,KAAhB,CAAjC;AACA;AACA,KAAI,CAACxF,uBAAuByF,wBAAvB,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAMC,UAAUrC,OAAOsC,KAAP,CAAarE,YAAb,CAAhB;AACA,KAAIqD,IAAI,CAAR;AACA,QAAOA,IAAIe,QAAQ/B,MAAnB,EACA;AACC,MAAI+B,QAAQf,CAAR,KAAc,IAAd,IAAsBe,QAAQf,CAAR,EAAWhB,MAAX,GAAoB,CAA9C,EACA;AACC,UAAO;AACNN,YAAYoC,wBADN;AAEN5C,eAAY6C,QAAQf,CAAR;AAFN,IAAP;AAIA;AACDA;AACA;AACD","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport { matches_entirely } from './common'\r\n\r\nimport\r\n{\r\n\tget_phone_code,\r\n\tget_national_number_pattern,\r\n\tget_national_prefix_for_parsing,\r\n\tget_national_prefix_transform_rule,\r\n\tget_leading_digits,\r\n\tget_metadata_by_country_phone_code,\r\n\tget_formats,\r\n\t// get_format_national_prefix_is_mandatory_when_formatting\r\n}\r\nfrom './metadata'\r\n\r\nimport\r\n{\r\n\tchoose_format_for_number\r\n}\r\nfrom './format'\r\n\r\nimport get_number_type from './types'\r\n\r\n// The maximum length of the country calling code.\r\nconst MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// The minimum length of the national significant number.\r\nconst MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nconst MAX_LENGTH_FOR_NSN = 17\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nconst WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\n// Pattern to capture digits used in an extension.\r\n// Places a maximum length of '7' for an extension.\r\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nconst EXTN_PATTERNS_FOR_PARSING =\r\n\tRFC3966_EXTN_PREFIX +\r\n\tCAPTURING_EXTN_DIGITS + '|' +\r\n\t'[ \\u00A0\\\\t,]*' +\r\n\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\r\n\t'[;,x\\uFF58#\\uFF03~\\uFF5E]|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\r\n\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\r\n\tCAPTURING_EXTN_DIGITS + '#?|' +\r\n\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nconst VALID_PHONE_NUMBER =\r\n\t\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t\t'(?:' +\r\n\t\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t\t'[' + VALID_DIGITS + ']' +\r\n\t\t'){3,}' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\r\n(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER +\r\n\t\t// Phone number extensions\r\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\r\n\t'$'\r\n,\r\n'i')\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\r\n\r\n// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport const DIGIT_MAPPINGS =\r\n{\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\nconst default_options =\r\n{\r\n\tcountry: {}\r\n}\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(arg_1, arg_2, arg_3)\r\n{\r\n\tlet { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3)\r\n\r\n\t// Validate country codes\r\n\r\n\t// Validate `default` country\r\n\tif (options.country.default && !metadata.countries[options.country.default])\r\n\t{\r\n\t\tthrow new Error(`Unknown country code: ${options.country.default}`)\r\n\t}\r\n\r\n\t// Validate `restrict` country\r\n\tif (options.country.restrict && !metadata.countries[options.country.restrict])\r\n\t{\r\n\t\tthrow new Error(`Unknown country code: ${options.country.restrict}`)\r\n\t}\r\n\r\n\t// Parse the phone number\r\n\r\n\tlet formatted_phone_number\r\n\tlet extension\r\n\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\tfor (const part of text.split(';'))\r\n\t\t{\r\n\t\t\tconst [name, value] = part.split(':')\r\n\t\t\tswitch (name)\r\n\t\t\t{\r\n\t\t\t\tcase 'tel':\r\n\t\t\t\t\tformatted_phone_number = value\r\n\t\t\t\t\tbreak\r\n\t\t\t\tcase 'ext':\r\n\t\t\t\t\textension = value\r\n\t\t\t\t\tbreak\r\n\t\t\t\tcase 'phone-context':\r\n\t\t\t\t\t// Domain contexts are ignored.\r\n\t\t\t\t\tif (value[0] === '+')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tformatted_phone_number = value + formatted_phone_number\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tformatted_phone_number = extract_formatted_phone_number(text)\r\n\t}\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!is_viable_phone_number(formatted_phone_number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = strip_extension(formatted_phone_number)\r\n\r\n\tif (with_extension_stripped.extension)\r\n\t{\r\n\t\tformatted_phone_number = with_extension_stripped.number,\r\n\t\textension              = with_extension_stripped.extension\r\n\t}\r\n\r\n\tlet { country_phone_code, number } = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata)\r\n\r\n\t// Maybe invalid country phone code encountered\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet country\r\n\tlet country_metadata\r\n\r\n\t// Whether the phone number is formatted as an international phone number\r\n\tlet is_international = false\r\n\r\n\tif (country_phone_code)\r\n\t{\r\n\t\tis_international = true\r\n\r\n\t\t// Check country restriction\r\n\t\tif (options.country.restrict &&\r\n\t\t\tcountry_phone_code !== get_phone_code(metadata.countries[options.country.restrict]))\r\n\t\t{\r\n\t\t\treturn {}\r\n\t\t}\r\n\r\n\t\t// Formatting information for regions which share\r\n\t\t// a country calling code is contained by only one region\r\n\t\t// for performance reasons. For example, for NANPA region\r\n\t\t// (\"North American Numbering Plan Administration\",\r\n\t\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t\t// it will be contained in the metadata for `US`.\r\n\t\tcountry_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata)\r\n\r\n\t\t// `country` will be set later,\r\n\t\t// because, for example, for NANPA countries\r\n\t\t// there are several countries corresponding\r\n\t\t// to the same `1` country phone code.\r\n\t\t// Therefore, to reliably determine the exact country,\r\n\t\t// national (significant) number should be parsed first.\r\n\t}\r\n\telse if (options.country.restrict || options.country.default)\r\n\t{\r\n\t\tcountry = options.country.restrict || options.country.default\r\n\t\tcountry_metadata = metadata.countries[country]\r\n\r\n\t\tnumber = normalize(formatted_phone_number)\r\n\t}\r\n\r\n\tif (!country_metadata)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet national_number = number\r\n\r\n\t// Only strip national prefixes for non-international phone numbers\r\n\t// because national prefixes can't be present in international phone numbers.\r\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\r\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\r\n\t// and then it would assume that's a valid number which it isn't.\r\n\t// So no forgiveness for grandmas here.\r\n\t// The issue asking for this fix:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\r\n\tif (!is_international)\r\n\t{\r\n\t\tnational_number = strip_national_prefix(number, country_metadata)\r\n\t}\r\n\r\n\tconst did_have_national_prefix = national_number !== number\r\n\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/67\r\n\t// if (!is_international && !did_have_national_prefix &&\r\n\t// \t\tis_national_prefix_required(national_number, country_metadata))\r\n\t// {\r\n\t// \treturn {}\r\n\t// }\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\tif (!country)\r\n\t{\r\n\t\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t\t// get their countries populated with the full set of\r\n\t\t// \"phone number type\" regular expressions.\r\n\t\tcountry = find_country_code(country_phone_code, national_number, metadata)\r\n\r\n\t\t// Just in case there appears to be a bug in Google's metadata\r\n\t\t// and the exact country could not be extracted from the phone number.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (!country)\r\n\t\t{\r\n\t\t\treturn {}\r\n\t\t}\r\n\r\n\t\t// Update metadata to be for this specific country\r\n\t\tcountry_metadata = metadata.countries[country]\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (national_number.length > MAX_LENGTH_FOR_NSN)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\r\n\r\n\t// Check if national phone number pattern matches the number\r\n\tif (!matches_entirely(national_number, national_number_rule))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone: national_number\r\n\t}\r\n\r\n\tif (extension)\r\n\t{\r\n\t\tresult.ext = extension\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n// Normalizes a string of characters representing a phone number.\r\n// This converts wide-ascii and arabic-indic numerals to European numerals,\r\n// and strips punctuation and alpha characters.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\r\n//\r\nexport function normalize(number)\r\n{\r\n\treturn replace_characters(number, DIGIT_MAPPINGS)\r\n}\r\n\r\n// For any character not being part of `replacements`\r\n// it is removed from the phone number.\r\nexport function replace_characters(text, replacements)\r\n{\r\n\tlet replaced = ''\r\n\r\n\tfor (const character of text)\r\n\t{\r\n\t\tconst replacement = replacements[character.toUpperCase()]\r\n\r\n\t\tif (replacement !== undefined)\r\n\t\t{\r\n\t\t\treplaced += replacement\r\n\t\t}\r\n\t}\r\n\r\n\treturn replaced\r\n}\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport function is_viable_phone_number(number)\r\n{\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tmatches_entirely(number, VALID_PHONE_NUMBER_PATTERN)\r\n}\r\n\r\nexport function extract_formatted_phone_number(text)\r\n{\r\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Parses a formatted phone number.\r\nexport function parse_phone_number(number)\r\n{\r\n\tif (!number)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\tconst is_international = LEADING_PLUS_CHARS_PATTERN.test(number)\r\n\r\n\t// Remove non-digits\r\n\t// (and strip the possible leading '+')\r\n\tnumber = normalize(number)\r\n\r\n\tif (is_international)\r\n\t{\r\n\t\treturn `+${number}`\r\n\t}\r\n\r\n\treturn number\r\n}\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ country_phone_code, number }`\r\n// where `number` is the national (significant) phone number.\r\n//\r\n// (aka `maybeExtractCountryPhoneCode`)\r\n//\r\nexport function parse_phone_number_and_country_phone_code(number, metadata)\r\n{\r\n\tnumber = parse_phone_number(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// Strip the leading '+' sign\r\n\tnumber = number.slice(1)\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[0] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 1\r\n\twhile (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst country_phone_code = number.slice(0, i)\r\n\r\n\t\tif (metadata.country_phone_code_to_countries[country_phone_code])\r\n\t\t{\r\n\t\t\treturn { country_phone_code, number: number.slice(i) }\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided\r\nexport function strip_national_prefix(number, country_metadata)\r\n{\r\n\tconst national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata)\r\n\r\n\tif (!number || !national_prefix_for_parsing)\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but if the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\r\n\tlet national_significant_number\r\n\r\n\t// `national_prefix_for_parsing` capturing groups\r\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\r\n\tconst any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1]\r\n\tconst national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata)\r\n\r\n\t// If the national number tranformation is needed then do it\r\n\tif (national_prefix_transform_rule && any_groups_were_captured)\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule)\r\n\t}\r\n\t// Else, no transformation is necessary,\r\n\t// and just strip the national prefix.\r\n\telse\r\n\t{\r\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\r\n\t}\r\n\r\n\t// Verify the parsed national (significant) number for this country\r\n\tconst national_number_rule = new RegExp(get_national_number_pattern(country_metadata))\r\n\r\n\t// If the original number (before stripping national prefix) was viable,\r\n\t// and the resultant number is not, then prefer the original phone number.\r\n\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// a national prefix and a leading digit of a valid national phone number,\r\n\t// like `8` is the national prefix for Russia and both\r\n\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\tif (matches_entirely(number, national_number_rule) &&\r\n\t\t\t!matches_entirely(national_significant_number, national_number_rule))\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\t// Return the parsed national (significant) number\r\n   return national_significant_number\r\n}\r\n\r\nexport function find_country_code(country_phone_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_phone_code` is always valid\r\n\tconst possible_countries = metadata.country_phone_code_to_countries[country_phone_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\tfor (let country_code of possible_countries)\r\n\t{\r\n\t\tconst country = metadata.countries[country_code]\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (get_leading_digits(country))\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(get_leading_digits(country)) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country_code\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those bulky\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (get_number_type({ phone: national_phone_number, country: country_code }, metadata))\r\n\t\t{\r\n\t\t\treturn country_code\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// export function is_national_prefix_required(national_number, country_metadata)\r\n// {\r\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\r\n//\r\n// \tif (format)\r\n// \t{\r\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\r\n// \t}\r\n// }\r\n\r\n// Sort out arguments\r\nfunction sort_out_arguments(arg_1, arg_2, arg_3)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// Normalize numerical `value`.\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\r\n\t// `parse(88005553535, ...)`.\r\n\tif (typeof arg_1 === 'number')\r\n\t{\r\n\t\targ_1 = String(arg_1)\r\n\t}\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parse('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\ttext = arg_1\r\n\t}\r\n\r\n\t// If \"resrict country\" argument is being passed\r\n\t// then convert it to an `options` object.\r\n\t// `parse('88005553535', 'RU', [options], metadata)`.\r\n\tif (typeof arg_2 === 'string')\r\n\t{\r\n\t\toptions = { country: { restrict: arg_2 } }\r\n\t\tmetadata = arg_3\r\n\t}\r\n\t// No \"resrict country\" argument is being passed.\r\n\t// International phone number is passed.\r\n\t// `parse('+78005553535', [options], metadata)`.\r\n\telse\r\n\t{\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\r\n\t// Metadata is required.\r\n\tif (!metadata || !metadata.countries)\r\n\t{\r\n\t\tthrow new Error('Metadata is required')\r\n\t}\r\n\r\n\t// Apply default options.\r\n\tif (options)\r\n\t{\r\n\t\toptions = { ...default_options, ...options }\r\n\t}\r\n\telse\r\n\t{\r\n\t\toptions = default_options\r\n\t}\r\n\r\n\treturn { text, options, metadata }\r\n}\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nfunction strip_extension(number)\r\n{\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst number_without_extension = number.slice(0, start)\r\n\t/* istanbul ignore if - seems a bit of a redundant check */\r\n\tif (!is_viable_phone_number(number_without_extension))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length)\r\n\t{\r\n\t\tif (matches[i] != null && matches[i].length > 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tnumber    : number_without_extension,\r\n\t\t\t\textension : matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n"]}