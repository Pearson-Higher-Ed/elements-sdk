{"version":3,"sources":["../source/types.js"],"names":["get_number_type","is_of_type","sort_out_arguments","arg_1","arg_2","arg_3","input","metadata","country","national_number","phone","country_metadata","countries","type","String","undefined","Error"],"mappings":"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","file":"types.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\r\n\r\nimport { matches_entirely } from './common'\r\n\r\nimport\r\n{\r\n\tget_national_number_pattern,\r\n\tget_type_fixed_line,\r\n\tget_type_mobile,\r\n\tget_type_toll_free,\r\n\tget_type_premium_rate,\r\n\tget_type_personal_number,\r\n\tget_type_voice_mail,\r\n\tget_type_uan,\r\n\tget_type_pager,\r\n\tget_type_voip,\r\n\tget_type_shared_cost\r\n}\r\nfrom './metadata'\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function get_number_type(arg_1, arg_2, arg_3)\r\n{\r\n\tconst { input, metadata } = sort_out_arguments(arg_1, arg_2, arg_3)\r\n\r\n\t// When no input was passed\r\n\tif (!input)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// When `parse()` returned `{}`\r\n\t// meaning that the phone number is not a valid one.\r\n\tif (!input.country)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tconst national_number = input.phone\r\n\tconst country_metadata = metadata.countries[input.country]\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!is_of_type(national_number, get_national_number_pattern(country_metadata)))\r\n\t{\r\n\t\treturn // 'UNKNOWN'\r\n\t}\r\n\r\n\tif (is_of_type(national_number, get_type_premium_rate(country_metadata)))\r\n\t{\r\n\t\treturn 'PREMIUM_RATE'\r\n\t}\r\n\r\n\tif (is_of_type(national_number, get_type_toll_free(country_metadata)))\r\n\t{\r\n\t\treturn 'TOLL_FREE'\r\n\t}\r\n\r\n\t/* istanbul ignore if */\r\n\tif (is_of_type(national_number, get_type_shared_cost(country_metadata)))\r\n\t{\r\n\t\treturn 'SHARED_COST'\r\n\t}\r\n\r\n\t/* istanbul ignore if */\r\n\tif (is_of_type(national_number, get_type_voip(country_metadata)))\r\n\t{\r\n\t\treturn 'VOIP'\r\n\t}\r\n\r\n\tif (is_of_type(national_number, get_type_personal_number(country_metadata)))\r\n\t{\r\n\t\treturn 'PERSONAL_NUMBER'\r\n\t}\r\n\r\n\t/* istanbul ignore if */\r\n\tif (is_of_type(national_number, get_type_pager(country_metadata)))\r\n\t{\r\n\t\treturn 'PAGER'\r\n\t}\r\n\r\n\t/* istanbul ignore if */\r\n\tif (is_of_type(national_number, get_type_uan(country_metadata)))\r\n\t{\r\n\t\treturn 'UAN'\r\n\t}\r\n\r\n\t/* istanbul ignore if */\r\n\tif (is_of_type(national_number, get_type_voice_mail(country_metadata)))\r\n\t{\r\n\t\treturn 'VOICEMAIL'\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (is_of_type(national_number, get_type_fixed_line(country_metadata)))\r\n\t{\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if there's no \"mobile\" pattern\r\n\t\t// then it means it was removed due to being a duplicate of some other pattern.\r\n\t\t//\r\n\t\tif (!get_type_mobile(country_metadata))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (is_of_type(national_number, get_type_mobile(country_metadata)))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tif (is_of_type(national_number, get_type_mobile(country_metadata)))\r\n\t{\r\n\t\treturn 'MOBILE'\r\n\t}\r\n\r\n\t// return 'UNKNOWN'\r\n}\r\n\r\nexport function is_of_type(national_number, type)\r\n{\r\n\t// // Check if any possible number lengths are present;\r\n\t// // if so, we use them to avoid checking\r\n\t// // the validation pattern if they don't match.\r\n\t// // If they are absent, this means they match\r\n\t// // the general description, which we have\r\n\t// // already checked before a specific number type.\r\n\t// if (get_possible_lengths(type) &&\r\n\t// \tget_possible_lengths(type).indexOf(national_number.length) === -1)\r\n\t// {\r\n\t// \treturn false\r\n\t// }\r\n\r\n\t// get_type_pattern(type) === type\r\n\treturn matches_entirely(national_number, type)\r\n}\r\n\r\n// Sort out arguments\r\nexport function sort_out_arguments(arg_1, arg_2, arg_3)\r\n{\r\n\tlet input\r\n\tlet metadata\r\n\r\n\t// Normalize numerical `value`.\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\r\n\t// `getNumberType(88005553535, ...)`.\r\n\tif (typeof arg_1 === 'number')\r\n\t{\r\n\t\targ_1 = String(arg_1)\r\n\t}\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `getNumberType('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\t// If \"resrict country\" argument is being passed\r\n\t\t// then convert it to an `options` object.\r\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\r\n\t\tif (typeof arg_2 === 'string' || arg_2 === undefined)\r\n\t\t{\r\n\t\t\tmetadata = arg_3\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, arg_2, metadata)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// No \"resrict country\" argument is being passed.\r\n\t\t// International phone number is passed.\r\n\t\t// `getNumberType('+78005553535', metadata)`.\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, metadata)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// If the phone number is passed as a parsed phone number.\r\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\r\n\telse\r\n\t{\r\n\t\t// The `arg_1` must be a valid phone number\r\n\t\t// as a whole, not just a part of it which gets parsed here.\r\n\t\tif (arg_1 && arg_1.phone && is_viable_phone_number(arg_1.phone))\r\n\t\t{\r\n\t\t\tinput = arg_1\r\n\t\t}\r\n\r\n\t\tmetadata = arg_2\r\n\t}\r\n\r\n\t// Metadata is required.\r\n\tif (!metadata || !metadata.countries)\r\n\t{\r\n\t\tthrow new Error('Metadata is required')\r\n\t}\r\n\r\n\treturn { input, metadata }\r\n}"]}