'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactDayPicker = require('react-day-picker');

var _reactDayPicker2 = _interopRequireDefault(_reactDayPicker);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _dom = require('./utility/dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Derived from `react-day-picker` example
// http://react-day-picker.js.org/examples/?overlay

// // Moment.js takes 161 KB of space (minified) which is too much
// import moment from 'moment'

// // `date-fns` would be a better alternative to moment
// // but it doesn't support templated date parsing
// // until version `2.0.0` of it is released.
// // https://github.com/date-fns/date-fns/issues/347
// import parse_date_date_fns from 'date-fns/parse'
// import format_date_date_fns from 'date-fns/format'

var DatePicker = function (_PureComponent) {
	_inherits(DatePicker, _PureComponent);

	function DatePicker() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, DatePicker);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			expanded: false,
			selected_day: null
		}, _this.on_input_focus = function (event) {
			var onFocus = _this.props.onFocus;


			if (onFocus) {
				onFocus(event);
			}

			_this.expand();
		}, _this.expand = function () {
			var expanded = _this.state.expanded;
			var _this$props = _this.props,
			    value = _this$props.value,
			    format = _this$props.format,
			    onToggle = _this$props.onToggle;


			if (expanded) {
				return;
			}

			_this.setState({
				month: undefined
			}, function () {
				if (onToggle) {
					onToggle(true);
				}

				_this.setState({
					text_value: format_date(value, format),
					expanded: true,
					month: value ? normalize_value(value) : new Date()
				});

				// Could also focus on the calendar controls upon expansion
				// but it's configured to collapse on Tab event.
				// , () =>
				// {
				// 	ReactDOM.findDOMNode(this.calendar).focus()
				// })
			});
		}, _this.on_key_down_in_container = function (event) {
			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			var expanded = _this.state.expanded;


			switch (event.keyCode) {
				// Collapse on Escape or on Tab out
				case 27:
					event.preventDefault();
					_this.input.focus();
				case 9:
					if (expanded) {
						_this.collapse();
					}
					return;
			}
		}, _this.on_input_key_down = function (event) {
			var onKeyDown = _this.props.onKeyDown;


			if (onKeyDown) {
				onKeyDown(event);
			}

			if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {
				return;
			}

			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			var expanded = _this.state.expanded;


			switch (event.keyCode) {
				// Collapse on Escape and on Enter
				case 27:
					event.preventDefault();
				case 13:
					if (expanded) {
						_this.collapse();
					}
					return;

				// Toggle the calendar on Spacebar
				case 32:
					event.preventDefault();

					if (expanded) {
						_this.collapse();
					} else {
						_this.expand();
					}

					return;

				// Collapse the calendar (if expanded) on Up arrow
				case 38:
					if (expanded) {
						event.preventDefault();
						_this.collapse();
					}
					return;

				// Expand the calendar (if collapsed) on Down arrow
				case 40:
					if (!expanded) {
						event.preventDefault();
						_this.expand();
					}
					return;
			}
		}, _this.collapse = function () {
			var onToggle = _this.props.onToggle;


			if (onToggle) {
				onToggle(false);
			}

			_this.setState({
				text_value: undefined,
				expanded: false
			});

			// `onChange` fires on calendar day `click`
			// but the `value` hasn't neccessarily been updated yet,
			// therefore, say, if `value` was not set
			// and a user select a day in the calendar
			// then the `value` is technically still `undefined`
			// so can't just set `state.text_value = format_date(value)` here.
			//
			// Analogous, `setState({ text_value })` has been called
			// in calendar day `onClick` but `state.text_value`
			// hasn't neccessarily been updated yet.
			//
			// Still must validate (recompute) `text_value` on `<input/>` blur
			// in cases when a user manually typed in a date and then tabbed away.
		}, _this.on_input_change = function (event) {
			var _this$props2 = _this.props,
			    onChange = _this$props2.onChange,
			    previous_value = _this$props2.value,
			    format = _this$props2.format,
			    noon = _this$props2.noon,
			    utc = _this$props2.utc,
			    disabledDays = _this$props2.disabledDays;
			var value = event.target.value;


			value = value.trim();

			// When the date is erased, reset it.
			if (!value) {
				// Call `onChange` only if `value` did actually change
				if (previous_value) {
					onChange(undefined);
				}

				return _this.setState({ text_value: '' });
			}

			value = trim_invalid_part(value, format);

			var selected_day = parse_date(value, format, noon, utc);

			// If the date input is unparseable,
			// or if it's one of the disabled days,
			// then don't change the selected date.
			if (!selected_day || disabledDays && _reactDayPicker.ModifiersUtils.dayMatchesModifier(selected_day, disabledDays)) {
				return _this.setState({ text_value: value });
			}

			// Call `onChange` only if `value` did actually change
			if (!previous_value || previous_value.getTime() !== selected_day.getTime()) {
				onChange(selected_day);
			}

			_this.setState({
				text_value: value
			}, function () {
				return _this.calendar.showMonth(selected_day);
			});
		}, _this.on_day_click = function (selected_day, _ref2) {
			var disabled = _ref2.disabled;
			var _this$props3 = _this.props,
			    format = _this$props3.format,
			    onChange = _this$props3.onChange,
			    previous_value = _this$props3.value,
			    noon = _this$props3.noon,
			    utc = _this$props3.utc;

			// If the day clicked is disabled then do nothing.

			if (disabled) {
				return;
			}

			// https://github.com/gpbl/react-day-picker/issues/473
			// By default the `selected_day` has time
			// set to `12:00` of the current time zone.
			// These extra 12 hours do make sense and
			// do help make things less weird.
			//
			// These extra 12 hours are a hack to make things
			// a little bit less weird when rendering parsed dates.
			// E.g. if a date `Jan 1st, 2017` gets parsed as
			// `Jan 1st, 2017, 00:00 UTC+0` (England) then when displayed in the US
			// it would show up as `Dec 31st, 2016, 19:00 UTC-05` (Austin, Texas).
			// That would be weird for a website user.
			// Therefore this extra 12-hour padding is added
			// to compensate for the most weird cases like this
			// for adjacent countries / neighbours / same continent countries.
			//
			// So `selected_day` is in the user's time zone and the time is `12:00`.

			if (!noon) {
				// Here I strip those 12 hours from the `selected_day`
				// so the time becomes `00:00` in the user's time zone.
				//
				// (`selected_day` is the date in the user's time zone)
				// (`selected_day.getDate()` returns the day in the user's time zone)
				// (`new Date(year, month, day)` creates a date in the user's time zone)
				//
				selected_day = new Date(selected_day.getFullYear(), selected_day.getMonth(), selected_day.getDate());
			}

			if (utc) {
				// Converts timezone to UTC while preserving the same time
				selected_day = convert_to_utc_timezone(selected_day);
			}

			// `onChange` fires but the `value`
			// hasn't neccessarily been updated yet.
			//
			// Call `onChange` only if `value` did actually change.
			//
			if (!previous_value || previous_value.getTime() !== selected_day.getTime()) {
				onChange(selected_day);
			}

			// this.setState
			// ({
			// 	// text_value: format_date(selected_day, format),
			// 	expanded: false
			// })

			// // Blur the input so that the calendar
			// // will open upon a future click on it.
			// // (doesn't work in mobile browsers)
			// this.input.blur()

			// Hide the calendar
			_this.collapse();

			// Focus the `<input/>`
			_this.input.focus();
		}, _this.on_calendar_key_down = function (event) {
			switch (event) {
				// The next year is selected on "Up" arrow,
				// so `.preventDefault()` it to prevent page scrolling.
				// https://github.com/gpbl/react-day-picker/issues/273
				case 38:
					event.preventDefault();
					return;

				// The previous year is selected on "Down" arrow,
				// so `.preventDefault()` it to prevent page scrolling.
				// https://github.com/gpbl/react-day-picker/issues/273
				case 40:
					event.preventDefault();
					return;
			}
		}, _this.document_clicked = function (event) {
			var container = _reactDom2.default.findDOMNode(_this.container);

			if (container.contains(event.target)) {
				return;
			}

			_this.collapse();
		}, _this.on_month_selected = function (month) {
			_this.setState({ month: month });
		}, _this.on_blur = function (event) {
			var _this$props4 = _this.props,
			    onBlur = _this$props4.onBlur,
			    value = _this$props4.value;

			// If clicked on an expanded calendar then don't trigger "blur" event

			if (event.relatedTarget && event.currentTarget.contains(event.relatedTarget)) {
				return;
			}

			// This `onBlur` interceptor is a workaround for `redux-form`,
			// so that it gets the right (parsed, not the formatted one)
			// `event.target.value` in its `onBlur` handler.
			if (onBlur) {
				var _event = _extends({}, event, {
					target: _extends({}, event.target, {
						value: value
					})

					// For `redux-form` event detection.
					// https://github.com/erikras/redux-form/blob/v5/src/events/isEvent.js
				});_event.stopPropagation = event.stopPropagation;
				_event.preventDefault = event.preventDefault;

				onBlur(_event);
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(DatePicker, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			document.addEventListener('click', this.document_clicked);

			// Set "previous" and "next" buttons untabbable
			// so that a Tab out of the `<input/>` field
			// moves cursor not inside to these buttons
			// but rather to the next form input.
			var calendar = _reactDom2.default.findDOMNode(this.calendar);
			// Requires ES6 Symbol.Iterator polyfill.
			// for (const button of calendar.querySelectorAll('.DayPicker-NavButton'))
			for (var _iterator = [].slice.call(calendar.querySelectorAll('.DayPicker-NavButton')), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref3;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref3 = _iterator[_i++];
				} else {
					_i = _iterator.next();
					if (_i.done) break;
					_ref3 = _i.value;
				}

				var button = _ref3;

				button.removeAttribute('tabindex');
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			document.removeEventListener('click', this.document_clicked);
		}

		// Would have used `onBlur={...}` event handler here
		// with `if (container.contains(event.relatedTarget))` condition,
		// but it doesn't work in IE in React.
		// https://github.com/facebook/react/issues/3751
		//
		// Therefore, using the hacky `document.onClick` handlers
		// and this `onKeyDown` Tab handler
		// until `event.relatedTarget` support is consistent in React.
		//


		// Hides the day picker calendar and cancels textual date editing

	}, {
		key: 'should_indicate_invalid',


		// Whether should indicate that the input value is invalid
		value: function should_indicate_invalid() {
			var _props = this.props,
			    indicateInvalid = _props.indicateInvalid,
			    error = _props.error;


			return indicateInvalid && error;
		}

		// This handler is a workaround for `redux-form`

	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props2 = this.props,
			    id = _props2.id,
			    format = _props2.format,
			    value = _props2.value,
			    error = _props2.error,
			    disabledDays = _props2.disabledDays,
			    selectYearsIntoPast = _props2.selectYearsIntoPast,
			    selectYearsIntoFuture = _props2.selectYearsIntoFuture,
			    firstDayOfWeek = _props2.firstDayOfWeek,
			    disabled = _props2.disabled,
			    required = _props2.required,
			    label = _props2.label,
			    placeholder = _props2.placeholder,
			    closeButtonLabel = _props2.closeButtonLabel,
			    icon = _props2.icon,
			    className = _props2.className,
			    style = _props2.style;
			var _state = this.state,
			    text_value = _state.text_value,
			    expanded = _state.expanded,
			    month = _state.month;

			// `<input type="date"/>` renders a browser-specific date picker
			// which can not be turned off using a simple HTML attribute
			// and also date format is not customizable,
			// therefore just using `<input type="text"/>` here

			var captionElement = void 0;

			if (selectYearsIntoPast || selectYearsIntoFuture) {
				captionElement = _react2.default.createElement(YearMonthSelector, {
					selectedDay: value,
					onChange: this.on_month_selected,
					selectYearsIntoPast: selectYearsIntoPast,
					selectYearsIntoFuture: selectYearsIntoFuture });
			}

			return _react2.default.createElement(
				'div',
				{
					ref: function ref(_ref6) {
						return _this2.container = _ref6;
					},
					onKeyDown: this.on_key_down_in_container,
					onBlur: this.on_blur,
					className: (0, _classnames2.default)('rrui__date-picker', className, {
						'rrui__date-picker--disabled': disabled
					}),
					style: style },
				_react2.default.createElement(
					'div',
					{ className: 'rrui__input' },
					_react2.default.createElement(
						'div',
						{ className: 'rrui__date-picker__icon' },
						icon
					),
					_react2.default.createElement('div', {
						onClick: this.expand,
						className: 'rrui__date-picker__input-overlay' }),
					_react2.default.createElement('input', {
						id: id,
						type: 'text',
						ref: function ref(_ref4) {
							return _this2.input = _ref4;
						},
						placeholder: placeholder || (typeof format === 'string' ? format : undefined),
						disabled: disabled,
						value: text_value !== undefined ? text_value : format_date(value, format),
						onKeyDown: this.on_input_key_down,
						onChange: this.on_input_change,
						onFocus: this.on_input_focus,
						onClick: this.expand,
						className: (0, _classnames2.default)('rrui__input-element', 'rrui__input-field', {
							'rrui__input-field--invalid': this.should_indicate_invalid(),
							'rrui__input-field--disabled': disabled
						}) }),
					label && _react2.default.createElement(
						'label',
						{
							htmlFor: id,
							className: (0, _classnames2.default)('rrui__input-label', {
								'rrui__input-label--required': required && !value,
								'rrui__input-label--invalid': this.should_indicate_invalid()
							}) },
						label
					),
					_react2.default.createElement(
						'div',
						{
							className: (0, _classnames2.default)('rrui__expandable', 'rrui__expandable--overlay', 'rrui__shadow', 'rrui__date-picker__collapsible', {
								'rrui__expandable--expanded': expanded
							}) },
						_react2.default.createElement(
							'div',
							{
								className: (0, _classnames2.default)('rrui__expandable__content', {
									// CSS selector performance optimization
									'rrui__expandable__content--expanded': expanded
								}) },
							_react2.default.createElement(_reactDayPicker2.default, {
								ref: function ref(_ref5) {
									return _this2.calendar = _ref5;
								},
								month: month,
								firstDayOfWeek: firstDayOfWeek,
								onDayClick: this.on_day_click,
								onKeyDown: this.on_calendar_key_down,
								selectedDays: normalize_value(value),
								disabledDays: disabledDays,
								captionElement: captionElement,
								tabIndex: -1,
								className: 'rrui__date-picker__calendar' }),
							_react2.default.createElement(
								'button',
								{
									type: 'button',
									onClick: this.collapse,
									className: (0, _classnames2.default)('rrui__button-reset', 'rrui__date-picker__close') },
								closeButtonLabel
							)
						)
					)
				),
				this.should_indicate_invalid() && _react2.default.createElement(
					'div',
					{ className: 'rrui__input-error' },
					error
				)
			);
		}
	}]);

	return DatePicker;
}(_react.PureComponent);

// Parses a text value into a `Date` provided a `format`.
// The date returned is in the user's time zone and the time is `12:00`.


DatePicker.propTypes = {
	// An optional label placed on top of the input field
	label: _propTypes2.default.string,

	// `<input/>` placeholder
	placeholder: _propTypes2.default.string,

	// `0` means "Sunday", `1` means "Monday", etc.
	// (is `0` by default)
	firstDayOfWeek: _propTypes2.default.number.isRequired,

	// Date format. Only supports `DD`, `MM`, `YY` and `YYYY` for now (to reduce bundle size).
	// Can support custom localized formats, perhaps, when `date-fns@2` is released.
	// (is US `MM/DD/YYYY` by default)
	format: _propTypes2.default.string.isRequired,
	// format : PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,

	// Internationalization
	// locale : PropTypes.string,

	// The Date `value`
	value: _propTypes2.default.instanceOf(Date),

	// Writes new `value`.
	// The `value` is in the user's time zone and the time is `00:00`.
	onChange: _propTypes2.default.func.isRequired,

	// Is called when the date picker is either collapsed or expanded
	onToggle: _propTypes2.default.func,

	// Is called when the input is focused
	onFocus: _propTypes2.default.func,

	// Is called when the input is blurred.
	// This `onBlur` interceptor is a workaround for `redux-form`,
	// so that it gets the parsed `value` in its `onBlur` handler,
	// not the formatted text.
	onBlur: _propTypes2.default.func,

	// Disables the input
	disabled: _propTypes2.default.bool,

	// Set to `true` to mark the field as required
	required: _propTypes2.default.bool.isRequired,

	// HTML `<input/>` `name` attribute
	name: _propTypes2.default.string,

	// `react-day-picker`'s `disabledDays`.
	// http://react-day-picker.js.org/examples/disabled
	disabledDays: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func, _propTypes2.default.array]),

	// How much years back can a user navigate using the year `<select/>`
	selectYearsIntoPast: _propTypes2.default.number,

	// How much years forward can a user navigate using the year `<select/>`
	selectYearsIntoFuture: _propTypes2.default.number,

	// Whether dates being selected should be in UTC+0 timezone.
	// (is `false` by default)
	utc: _propTypes2.default.bool.isRequired,

	// Whether to set time to 12:00 for dates being selected.
	// (is `true` by default)
	noon: _propTypes2.default.bool.isRequired,

	// "Close" button title for fullscreen mode on mobile devices
	closeButtonLabel: _propTypes2.default.string.isRequired,

	// The calendar icon
	icon: _propTypes2.default.node,

	// CSS class
	className: _propTypes2.default.string,

	// CSS style object
	style: _propTypes2.default.object
};
DatePicker.defaultProps = {
	// Default US format
	format: 'MM/DD/YYYY',

	// locale: 'en-US',
	firstDayOfWeek: 0,

	// Set to `true` to mark the field as required
	required: false,

	// Whether dates being selected should be in UTC+0 timezone
	utc: false,

	// Whether to set time to 12:00 for dates being selected
	noon: true,

	// "Close" button title for fullscreen mode on mobile devices
	closeButtonLabel: 'Close'
};
exports.default = DatePicker;
function parse_date(text_value, format, noon, utc) {
	if (!text_value) {
		return;
	}

	// Custom
	return parse_date_custom(text_value, format, noon, utc);

	// // Using `date-fns`
	// const date = parse_date_date_fns(text_value)

	// if (isNaN(date.getTime()))
	// {
	// 	return
	// }

	// return date

	// // Using `Moment.js`
	// const moment_day = moment(text_value, format, true)

	// if (!moment_day.isValid())
	// {
	// 	return
	// }

	// return moment_day.toDate()
}

// (Moment.js)
// Formats a `Date` into a text value provided a `format`
function format_date(date, format) {
	// Custom
	return format_date_custom(date, format);

	// // Using `date-fns`
	// return format_date_date_fns(date, format)

	// // Using `Moment.js`
	// return moment(date).format(format)
}

// Parses a text value into a `Date` provided a `format`.
// The date returned is in the user's time zone and the time is `00:00`.
function parse_date_custom(string, format, noon, utc) {
	if (!string) {
		return;
	}

	var year = extract(string, format, 'YYYY');

	if (year === undefined) {
		year = extract(string, format, 'YY');

		if (year !== undefined) {
			// Current year in the user's time zone.
			var current_year = new Date().getFullYear();
			var current_year_century = current_year - current_year % 100;
			year += current_year_century;
		}
	}

	var month = extract(string, format, 'MM');
	var day = extract(string, format, 'DD');

	if (year === undefined || month === undefined || day === undefined) {
		return console.error('Couldn\'t parse date. Most likely an invalid date entered (manually). Otherwise it could be an unsupported date format: ' + format + ' (only DD, MM, YY and YYYY literals are supported).');
	}

	// The date created is in the user's time zone and the time is `00:00`.
	var date = new Date(year, month - 1, day, noon ? 12 : undefined);

	if (utc) {
		// Converts timezone to UTC while preserving the same time
		date = convert_to_utc_timezone(date);
	}

	// If `new Date()` returns "Invalid Date"
	// (sometimes it does)
	if (isNaN(date.getTime())) {
		return;
	}

	return date;
}

function extract(string, template, piece) {
	var starts_at = template.indexOf(piece);

	if (starts_at < 0) {
		return;
	}

	// Check overall sanity
	if (!corresponds_to_template(string, template)) {
		return;
	}

	var number = parseInt(string.slice(starts_at, starts_at + piece.length));

	if (!isNaN(number)) {
		return number;
	}
}

function corresponds_to_template(string, template) {
	if (string.length !== template.length) {
		return false;
	}

	var i = 0;
	while (i < string.length) {
		var is_a_digit = string[i] >= '0' && string[i] <= '9';

		if (!is_a_digit) {
			if (string[i] !== template[i]) {
				return false;
			}
		} else {
			if (template[i] !== 'D' && template[i] !== 'M' && template[i] !== 'Y') {
				return false;
			}
		}

		i++;
	}

	return true;
}

// console.log(corresponds_to_template('1231231234', 'DD.MM.YYYY'))
// console.log(corresponds_to_template('12.12.1234', 'DD.MM.YYYY'))

// console.log(parse_date_custom('fadsfasd', 'DD.MM.YYYY'))
// console.log(parse_date_custom('28.02.2017', 'DD.MM.YYYY'))
// console.log(parse_date_custom('12/02/2017', 'MM/DD/YYYY'))
// console.log(parse_date_custom('99/99/2017', 'MM/DD/YYYY'))
// console.log(parse_date_custom('02/03/17', 'MM/DD/YY'))

function format_date_custom(date, format) {
	// Someone may accidentally pass a timestamp, or a string.
	// Or `date` could be `undefined`.
	if (!(date instanceof Date)) {
		return '';
	}

	// Check if `date` is "Invalid Date".
	if (isNaN(date.getTime())) {
		return '';
	}

	var day = date.getDate();
	var month = date.getMonth() + 1;
	var year = date.getFullYear();

	var text = format.replace('DD', pad_with_zeroes(String(day), 2)).replace('MM', pad_with_zeroes(String(month), 2));

	if (text.indexOf('YYYY') >= 0) {
		return text.replace('YYYY', pad_with_zeroes(String(year), 4));
	}

	if (text.indexOf('YY') >= 0) {
		return text.replace('YY', pad_with_zeroes(String(year % 100), 2));
	}
}

// console.log(format_date_custom(new Date(), 'DD.MM.YYYY'))
// console.log(format_date_custom(new Date(), 'MM/DD/YYYY'))
// console.log(format_date_custom(new Date(), 'MM/DD/YY'))

function pad_with_zeroes(string, target_length) {
	while (string.length < target_length) {
		string = '0' + string;
	}

	return string;
}

// // Intl date formatting
//
// const dateFormatters = {}
//
// function format_dateIntl(date, locale) {
//   if (typeof Intl === 'undefined') {
//     return date.toISOString()
//   }
//
//   const key = typeof locale === 'string' ? locale : locale.join(',')
//
//   if (!dateFormatters[key]) {
//     dateFormatters[key] = new Intl.DateTimeFormat(locale, {
//       day: '2-digit',
//       month: '2-digit',
//       year: 'numeric'
//     })
//   }
//
//   return dateFormatters[key]
// }

// Converts `null` to `undefined`
// (specially for `knex.js`)
function normalize_value(value) {
	if (value === null) {
		return;
	}

	// Check if `value` is "Invalid Date".
	if (value instanceof Date && isNaN(value.getTime())) {
		return;
	}

	return value;
}

function trim_invalid_part(value, format) {
	var i = 0;
	while (i < value.length && i < format.length) {
		if (format[i] === 'D' || format[i] === 'M' || format[i] === 'Y') {
			if (!(value[i] >= '0' && value[i] <= '9')) {
				break;
			}
		} else if (format[i] !== value[i]) {
			break;
		}
		i++;
	}

	return value.slice(0, i);
}

// console.log(trim_invalid_part('fasdf', 'DD.MM.YYYY'))
// console.log(trim_invalid_part('01.01.1234', 'DD.MM.YYYY'))
// console.log(trim_invalid_part('01/02/34', 'MM/DD/YY'))
// console.log(trim_invalid_part('01/a2/34', 'MM/DD/YY'))

// http://react-day-picker.js.org/examples/?yearNavigation
// Component will receive date, locale and localeUtils props
function YearMonthSelector(_ref7) {
	var date = _ref7.date,
	    localeUtils = _ref7.localeUtils,
	    onChange = _ref7.onChange,
	    selectYearsIntoPast = _ref7.selectYearsIntoPast,
	    selectYearsIntoFuture = _ref7.selectYearsIntoFuture,
	    selectedDay = _ref7.selectedDay;

	// The current year in the user's time zone.
	var current_year = new Date().getFullYear();

	var from_year = selectYearsIntoPast ? current_year - selectYearsIntoPast : current_year;
	var to_year = selectYearsIntoFuture ? current_year + selectYearsIntoFuture : current_year;

	var years = new Array(to_year - from_year + 1);

	var i = 0;
	while (from_year + i <= to_year) {
		years[i] = from_year + i;
		i++;
	}

	// Makes sure the currently selected year is in the list
	// to not confuse the user.
	if (selectedDay) {
		var selected_year = selectedDay.getFullYear();

		if (selected_year < from_year) {
			years.unshift(selected_year);
		} else if (selected_year > to_year) {
			years.push(selected_year);
		}
	}

	var months = localeUtils.getMonths();

	function on_change(event) {
		var month = event.target.parentNode.firstChild.value;
		var year = event.target.parentNode.lastChild.value;

		// The date created is in the user's time zone and the time is `00:00`.
		// The `day` is `undefined` which means the first one of the `month`.
		onChange(new Date(year, month));
	}

	return _react2.default.createElement(
		'div',
		{ className: 'DayPicker-Caption' },
		_react2.default.createElement(
			'div',
			{ className: 'DayPicker-CaptionSelects' },
			_react2.default.createElement(
				'select',
				{
					onChange: on_change,
					value: date.getMonth(),
					tabIndex: -1,
					className: 'DayPicker-MonthSelect' },
				months.map(function (month, i) {
					return _react2.default.createElement(
						'option',
						{ key: i, value: i },
						month
					);
				})
			),
			_react2.default.createElement(
				'select',
				{
					onChange: on_change,
					value: date.getFullYear(),
					tabIndex: -1,
					className: 'DayPicker-YearSelect' },
				years.map(function (year, i) {
					return _react2.default.createElement(
						'option',
						{ key: i, value: year },
						year
					);
				})
			)
		)
	);
}

// Converts timezone to UTC while preserving the same time
function convert_to_utc_timezone(date) {
	// Doesn't account for leap seconds but I guess that's ok
	// given that javascript's own `Date()` does not either.
	// https://www.timeanddate.com/time/leap-seconds-background.html
	//
	// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
	//
	return new Date(date.getTime() - date.getTimezoneOffset() * 60 * 1000);
}
//# sourceMappingURL=DatePicker.js.map