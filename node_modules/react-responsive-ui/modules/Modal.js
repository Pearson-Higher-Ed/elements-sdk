var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import classNames from 'classnames';
import ReactModal from 'react-modal';

import Button from './Button';
import Form from './Form';

// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.

var Modal = function (_Component) {
	_inherits(Modal, _Component);

	function Modal() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Modal);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			form: 0
		}, _this.register_form = function () {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref2) {
				var form = _ref2.form;
				return { form: form + 1 };
			});
		}, _this.unregister_form = function () {
			if (_this.unmounted) {
				return;
			}

			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref3) {
				var form = _ref3.form;
				return { form: form - 1 };
			});
		}, _this.on_request_close = function (event) {
			var closeLabel = _this.props.closeLabel;
			var form = _this.state.form;

			// If the modal has an explicit "Cancel" button,
			// then allow closing it by hitting "Escape" key,
			// but don't close it on a click outside.
			// (because a user wouldn't want to loose form data due to a misclick)

			if (closeLabel && form && event && event.type !== 'keydown') {
				_this.indicate_cannot_close();
				return ReactDOM.findDOMNode(_this.content).parentNode.focus();
			}

			_this.close_if_not_busy();
		}, _this.close_if_not_busy = function () {
			var _this$props = _this.props,
			    busy = _this$props.busy,
			    wait = _this$props.wait,
			    close = _this$props.close,
			    closeTimeout = _this$props.closeTimeout;

			// For weird messed development mode cases

			if (_this.unmounted) {
				return;
			}

			// Don't close the modal if it's busy
			if (busy || wait) {
				return _this.indicate_cannot_close();
			}

			// Abruptly end "couldn't close" animation to make room for closing animation
			_this.setState({ could_not_close_because_busy: false });

			// Close the modal
			if (close) {
				close();
			}
		}, _this.on_after_open = function () {
			var afterOpen = _this.props.afterOpen;


			_this.adjust_scrollbar_after_open();

			if (afterOpen) {
				afterOpen();
			}
		}, _this.on_after_close = function () {
			var _this$props2 = _this.props,
			    afterClose = _this$props2.afterClose,
			    reset = _this$props2.reset;


			if (reset) {
				reset();
			}

			if (afterClose) {
				afterClose();
			}

			_this.adjust_scrollbar_after_close();
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Modal, [{
		key: 'getChildContext',
		value: function getChildContext() {
			var closeLabel = this.props.closeLabel;


			var context = {
				rrui__modal: {
					closeLabel: closeLabel,
					close_if_not_busy: this.close_if_not_busy,
					register_form: this.register_form,
					unregister_form: this.unregister_form
				}
			};

			return context;
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			var _props = this.props,
			    unmount = _props.unmount,
			    isOpen = _props.isOpen;


			if (!unmount) {
				if (!isOpen && nextProps.isOpen) {
					this.on_after_open();
				} else if (isOpen && !nextProps.isOpen) {
					this.on_after_close();
					this.reset_content_scroll();
				}
			}
		}

		// A modal itself umounts only when the user leaves a page,
		// so in a "Single Page Application", for example,
		// if this was a regular popup and a user could still navigate
		// away via a hyperlink then this code becomes neccessary.

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var isOpen = this.props.isOpen;


			this.unmounted = true;

			// If the modal is still open
			// while a user navigates away
			// then "close" it properly
			// (restore the document scrollbars, etc).
			if (isOpen) {
				this.on_after_close();
			}

			clearTimeout(this.could_not_close_because_busy_animation_timeout);
			this.could_not_close_because_busy_animation_timeout = undefined;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props2 = this.props,
			    busy = _props2.busy,
			    wait = _props2.wait,
			    fullscreen = _props2.fullscreen,
			    isOpen = _props2.isOpen,
			    closeTimeout = _props2.closeTimeout,
			    contentLabel = _props2.contentLabel,
			    title = _props2.title,
			    closeLabel = _props2.closeLabel,
			    closeButton = _props2.closeButton,
			    closeButtonIcon = _props2.closeButtonIcon,
			    actions = _props2.actions,
			    unmount = _props2.unmount,
			    style = _props2.style,
			    className = _props2.className,
			    overlayClassName = _props2.overlayClassName,
			    children = _props2.children;
			var _state = this.state,
			    could_not_close_because_busy = _state.could_not_close_because_busy,
			    form = _state.form;


			return React.createElement(
				ReactModal,
				{
					isOpen: unmount ? isOpen : true,
					onAfterOpen: unmount ? this.on_after_open : undefined,
					onRequestClose: this.on_request_close,
					closeTimeoutMS: closeTimeout,
					contentLabel: contentLabel,
					ariaHideApp: false,
					style: react_modal_style,
					overlayClassName: classNames('rrui__modal__overlay', {
						'rrui__modal__overlay--busy': busy || wait,
						'rrui__modal__overlay--fullscreen': fullscreen,
						'rrui__modal__overlay--hidden': !unmount && !isOpen
					}, overlayClassName),
					className: classNames('rrui__modal__container', {
						'rrui__modal__container--fullscreen': fullscreen
					}) },
				React.createElement('div', {
					className: classNames('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--top', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close }),
				React.createElement(
					ModalContent,
					{
						ref: function ref(_ref4) {
							return _this2.content = _ref4;
						},
						closeLabel: closeLabel,
						closeButton: closeButton,
						closeButtonIcon: closeButtonIcon,
						close: this.close_if_not_busy,
						style: style,
						className: className,
						fullscreen: fullscreen,
						could_not_close_because_busy: could_not_close_because_busy,
						form: form,
						busy: busy || wait,
						reset: this.on_after_close },
					children
				),
				React.createElement('div', {
					className: classNames('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--bottom', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close })
			);
		}
	}, {
		key: 'indicate_cannot_close',


		// Play "cannot close" animation on the modal
		value: function indicate_cannot_close() {
			var _this3 = this;

			var could_not_close_because_busy_animation_duration = this.props.could_not_close_because_busy_animation_duration;
			var could_not_close_because_busy = this.state.could_not_close_because_busy;


			if (!could_not_close_because_busy) {
				this.could_not_close_because_busy_animation_timeout = setTimeout(function () {
					_this3.could_not_close_because_busy_animation_timeout = undefined;
					_this3.setState({ could_not_close_because_busy: false });
				},
				// Give it a bit of extra time to finish the CSS animation
				could_not_close_because_busy_animation_duration * 1.1);

				this.setState({ could_not_close_because_busy: true });
			}
		}
	}, {
		key: 'reset_content_scroll',


		// If the user scrolled on a previously shown react-modal,
		// then reset that previously scrolled position.
		value: function reset_content_scroll() {
			document.querySelector('.ReactModal__Overlay').scrollTop = 0;
		}

		// Hides the main (body) scrollbar upon showing a modal
		// and also adjusts the width of all "full-width" elements
		// so that they don't expand no that the scrollbar is absent.
		//
		// This doesn't account for window resizes
		// but since my body is always `overflow: visible` (a good practice)
		// there's no difference and it should work in any scenario.
		//

	}, {
		key: 'adjust_scrollbar_after_open',
		value: function adjust_scrollbar_after_open() {
			// A dummy `<div/>` to measure
			// the difference in width
			// needed for the "full-width" elements
			// after the main (body) scrollbar is deliberately hidden.
			var div = document.createElement('div');
			div.style.position = 'fixed';
			div.style.left = 0;
			div.style.right = 0;
			document.body.appendChild(div);

			// Calculate the width of the dummy `<div/>`
			// before the main (body) scrollbar is deliberately hidden.
			var width_before = div.clientWidth;

			// Hide the main (body) scrollbar
			// so that when a user scrolls in an open modal
			// this `scroll` event doesn't go through
			// and scroll the main page.
			document.body.style.overflow = 'hidden';

			// All "full-width" elements will need their
			// width to be adjusted by this amount
			// because of the now-hidden main (body) scrollbar

			// Calculate the width of the dummy `<div/>`
			// after the main (body) scrollbar is deliberately hidden.
			var width_adjustment = div.clientWidth - width_before;

			document.body.removeChild(div);

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements
			// so that they don't expand by the width of the (now absent) scrollbar
			//
			for (var _iterator = get_full_width_elements(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref5;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref5 = _iterator[_i++];
				} else {
					_i = _iterator.next();
					if (_i.done) break;
					_ref5 = _i.value;
				}

				var element = _ref5;

				element.style.marginRight = width_adjustment + 'px';
			}

			this.reset_content_scroll();
		}
	}, {
		key: 'adjust_scrollbar_after_close',


		// Restores original `document` scrollbar.
		value: function adjust_scrollbar_after_close() {
			var _props3 = this.props,
			    bodyOverflowX = _props3.bodyOverflowX,
			    bodyOverflowY = _props3.bodyOverflowY;

			// All "full-width" elements will need their
			// width to be restored back to the original value
			// now that the main (body) scrollbar is being restored.

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements back to their original value
			// now that the main (body) scrollbar is being restored.
			//

			for (var _iterator2 = get_full_width_elements(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
				var _ref6;

				if (_isArray2) {
					if (_i2 >= _iterator2.length) break;
					_ref6 = _iterator2[_i2++];
				} else {
					_i2 = _iterator2.next();
					if (_i2.done) break;
					_ref6 = _i2.value;
				}

				var element = _ref6;

				element.style.marginRight = 0;
			}

			// Restore the main (body) scrollbar.
			document.body.style.overflowX = bodyOverflowX;
			document.body.style.overflowY = bodyOverflowY;
		}

		// Restores original `document` scrollbar
		// and resets the modal content (e.g. a form)

	}]);

	return Modal;
}(Component);

Modal.propTypes = {
	// If `true` then the modal is shown
	isOpen: PropTypes.bool.isRequired,

	// Closes the modal (must set the `isOpen` flag to `false`)
	close: PropTypes.func.isRequired,

	// A time required for CSS hiding animation to complete
	// (150 milliseconds by default)
	closeTimeout: PropTypes.number.isRequired,

	// Is called after the modal is shown
	afterOpen: PropTypes.func,

	// Is called after the modal is closed
	afterClose: PropTypes.func,

	// Enters fullscreen mode
	fullscreen: PropTypes.bool,

	// Modal content
	children: PropTypes.node,

	// Resets the modal on close
	// (e.g. could reset edited form fields)
	reset: PropTypes.func,

	// "Cancel" button label.
	// If set, the modal will have a "Cancel" button.
	// (only if `<Form.Actions/>` is found in content)
	closeLabel: PropTypes.string,

	// The default `overflow-x` of the <body/>.
	// Is `auto` by default.
	bodyOverflowX: PropTypes.string.isRequired,

	// The default `overflow-x` of the <body/>.
	// Is `scroll` by default
	// (which is better than `auto`
	//  because the document width won't be jumpy
	//  while navigating the website —
	//  it will be consistent across all pages)
	bodyOverflowY: PropTypes.string.isRequired,

	// `aria-label` for the modal.
	// (is "Popup" by default)
	contentLabel: PropTypes.string.isRequired,

	// An optional close button (like a cross).
	// This is not actually a "button"
	// but instead "button contents",
	// i.e. `closeButton` will be wrapped with a `<button/>`.
	closeButton: PropTypes.node,

	closeButtonIcon: PropTypes.func,

	// If set to `false` will prevent modal contents
	// from being unmounted when the modal is closed.
	unmount: PropTypes.bool.isRequired,

	// Internal property
	could_not_close_because_busy_animation_duration: PropTypes.number.isRequired,

	// CSS class for overlay (e.g. for fullscreen modal background color)
	overlayClassName: PropTypes.string,

	// CSS class
	className: PropTypes.string,

	// CSS style object
	style: PropTypes.object
};
Modal.defaultProps = {
	isOpen: false,

	bodyOverflowX: 'auto',
	// Prevents document width from jumping due to the
	// vertical scrollbar appearance/disappearance
	bodyOverflowY: 'scroll',

	// when changing this also change
	// your .ReactModal__Overlay and .ReactModal__Content
	// css transition times accordingly
	closeTimeout: 150, // ms

	contentLabel: 'Popup',

	// Modal contents are unmounted when the modal is closed by default
	unmount: true,

	// When changing this also change
	// `.rrui__modal--could-not-close-because-busy`
	// css transition time accordingly
	could_not_close_because_busy_animation_duration: 600 // ms
};
Modal.childContextTypes = {
	rrui__modal: PropTypes.object
};
export default Modal;

var ModalContent = function (_Component2) {
	_inherits(ModalContent, _Component2);

	function ModalContent() {
		_classCallCheck(this, ModalContent);

		return _possibleConstructorReturn(this, (ModalContent.__proto__ || Object.getPrototypeOf(ModalContent)).apply(this, arguments));
	}

	_createClass(ModalContent, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var reset = this.props.reset;


			if (reset) {
				reset();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props4 = this.props,
			    closeLabel = _props4.closeLabel,
			    close = _props4.close,
			    fullscreen = _props4.fullscreen,
			    children = _props4.children,
			    className = _props4.className,
			    style = _props4.style,
			    form = _props4.form,
			    could_not_close_because_busy = _props4.could_not_close_because_busy;


			return React.createElement(
				'div',
				{
					className: classNames('rrui__modal__content', {
						// CSS selector performance optimization
						'rrui__modal__content--fullscreen': fullscreen,

						// Strictly speaking it's not `.rrui__modal` but this CSS class name will do
						'rrui__modal--could-not-close-because-busy': could_not_close_because_busy
					}, className),
					style: style },
				React.createElement(
					'div',
					{ className: 'rrui__modal__content-body' },
					this.render_close_button(),
					children,
					closeLabel && !form && React.createElement(
						'div',
						{ className: 'rrui__form__actions' },
						React.createElement(
							Button,
							{
								className: classNames('rrui__modal__close', 'rrui__modal__close--bottom'),
								action: close },
							closeLabel
						)
					)
				)
			);
		}
	}, {
		key: 'render_close_button',
		value: function render_close_button() {
			var _props5 = this.props,
			    closeLabel = _props5.closeLabel,
			    closeButton = _props5.closeButton,
			    closeButtonIcon = _props5.closeButtonIcon,
			    close = _props5.close,
			    busy = _props5.busy,
			    wait = _props5.wait;


			if (!closeButton && !closeButtonIcon) {
				return;
			}

			return React.createElement(
				'button',
				{
					onClick: close,
					'aria-label': closeLabel,
					className: classNames('rrui__modal__close', 'rrui__modal__close--top', {
						'rrui__modal__close--busy': busy || wait
					}) },
				closeButton || React.createElement(closeButtonIcon)
			);
		}
	}]);

	return ModalContent;
}(Component);

var react_modal_style = {
	overlay: {
		position: 'fixed',
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		// Will show a scrollbar in case of modal content overflowing viewport height
		overflow: 'auto'
	}

	// "full-width" elements include `document.body`
	// and all `position: fixed` elements
	// which should be marked with this special CSS class.
	//
	// Make sure to add `.rrui__fixed-full-width` CSS class
	// to all full-width `position: fixed` elements.
	// Such elements must not be `width: 100%`
	// but rather `width: auto` or `left: 0; right: 0;`.
	//
};function get_full_width_elements() {
	// `Array.from` requires ES6 polyfill.
	// const full_width_elements = Array.from(document.querySelectorAll('.rrui__fixed-full-width'))
	var full_width_elements = [].slice.call(document.querySelectorAll('.rrui__fixed-full-width'));
	full_width_elements.push(document.body);
	return full_width_elements;
}
//# sourceMappingURL=Modal.js.map