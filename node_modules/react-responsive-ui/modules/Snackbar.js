var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import classNames from 'classnames';

// Sits at the bottom of a page and displays notifications

var Snackbar = function (_PureComponent) {
	_inherits(Snackbar, _PureComponent);

	function Snackbar() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Snackbar);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Snackbar.__proto__ || Object.getPrototypeOf(Snackbar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			values: []
		}, _this.next = function () {
			var values = _this.state.values;
			var _this$props = _this.props,
			    hideAnimationDuration = _this$props.hideAnimationDuration,
			    minTime = _this$props.minTime,
			    lengthTimeFactor = _this$props.lengthTimeFactor;

			// Get the next notification from the queue
			// (will be `undefined` if the queue is empty)

			var value = values.shift();

			// Reset the notification display
			_this.setState({ value: value, height: undefined, hiding: false });

			// If the queue is empty, then just exit
			if (!value) {
				return;
			}

			// `state.show` will be set to `true` later,
			// when the height of the element is measured
			// (which is after it renders)

			// Hide the notification after it expires
			_this.auto_hide_timer = setTimeout(function () {
				// Clearing memory
				_this.auto_hide_timer = undefined;

				// Start the hiding animation for the notification
				_this.setState({ show: false, hiding: true });

				// Display the next notification
				// after the currently being hidden one
				// finishes its hiding animation.
				_this.show_next_snack_timeout = setTimeout(function () {
					_this.show_next_snack_timeout = undefined;
					_this.next();
				}, hideAnimationDuration);
			},
			// The total display duration (in milliseconds) of a snack
			// is `minTime + message.length * lengthTimeFactor`
			value.duration || minTime + (typeof value.content === 'string' ? value.content.length * lengthTimeFactor : 0));
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Snackbar, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.auto_hide_timer);
			clearTimeout(this.show_next_snack_timeout);
			clearTimeout(this.show_snack_timeout);

			this.auto_hide_timer = undefined;
			this.show_next_snack_timeout = undefined;
			this.show_snack_timeout = undefined;
		}
	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(new_props) {
			var value = new_props.value,
			    reset = new_props.reset;

			// Redux has an optimization built in:
			// it won't rerender a `@connect`ed component
			// if its new `props` are shallowly equal to the previous ones.
			// Therefore, manually resetting the `value` property here
			// immediately after receiving it (a non-`undefined` value)
			// so that the same notification message could later be displayed.

			if (value) {
				// Normalize value (make it a plain javascript object)
				// if it's a string or a react element.
				if (!((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !value.props)) {
					value = { content: value };
				}

				// Add the notification to the queue
				this.push(value);
				// Reset the `value` property immediately
				reset();
			}
		}

		// Adds a notification to the queue

	}, {
		key: 'push',
		value: function push(new_value) {
			var _state = this.state,
			    values = _state.values,
			    value = _state.value;

			// Add the notification to the queue

			values.push(new_value);

			// If the notification queue was empty
			// then kick-start it.
			if (!value) {
				this.next();
			}
		}

		// Displays the next notification in the queue

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			var _this2 = this;

			var _state2 = this.state,
			    height = _state2.height,
			    value = _state2.value;

			// The notification DOM element has just been rendered
			// which means its dimensions are set by now.
			// Calculate the notification container DOM element height
			// so that the slide-from-bottom animation knows
			// its target Y-position for the CSS `translate` transform.

			if (height === undefined && value) {
				height = ReactDOM.findDOMNode(this.snackbar).offsetHeight;
				var anti_lag_timeout = 100; // Otherwise it would jump to fully shown in Chrome when there's a queue of snacks waiting to be shown
				this.setState({ height: height }, function () {
					_this2.show_snack_timeout = setTimeout(function () {
						_this2.show_snack_timeout = undefined;
						_this2.setState({ show: true });
					}, anti_lag_timeout);
				});
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			var _props = this.props,
			    hideAnimationDuration = _props.hideAnimationDuration,
			    type = _props.type;
			var _state3 = this.state,
			    show = _state3.show,
			    value = _state3.value,
			    height = _state3.height,
			    hiding = _state3.hiding;


			var y = 0;

			// If no snack is being shown,
			// or if a snack is about to be shown,
			// then shift it under the screen's bottom border
			// to show the slide-from-bottom animation at the next step.
			if (!show && height !== undefined) {
				y = height + 'px';
			}

			var container_style = {
				visibility: show ? 'visible' : 'hidden',
				transform: 'translateY(' + y + ')',
				transition: 'transform ' + hideAnimationDuration + 'ms ease-out, visibility ' + hideAnimationDuration + 'ms ease-out'
			};

			if (!show && !hiding) {
				container_style.transition = 'none';
			}

			var snackbar_text_style = {
				opacity: show ? 1 : 0,
				transition: 'opacity ' + hideAnimationDuration + 'ms cubic-bezier(0.23, 1, 0.32, 1) 0ms',
				overflow: 'hidden'
			};

			return React.createElement(
				'div',
				{
					style: container_style,
					className: 'rrui__snackbar__container' },
				React.createElement(
					'div',
					{
						ref: function ref(_ref2) {
							return _this3.snackbar = _ref2;
						},
						className: classNames('rrui__snackbar', value && value.type && 'rrui__snackbar--' + value.type) },
					React.createElement(
						'div',
						{
							style: snackbar_text_style,
							className: 'rrui__snackbar__text' },
						value && value.content
					)
				)
			);
		}
	}]);

	return Snackbar;
}(PureComponent);

Snackbar.propTypes = {
	// Snackbar value (either a message, or an object)
	value: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
		content: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
		type: PropTypes.string,
		duration: PropTypes.number
	})]),

	// Must reset the `value`.
	reset: PropTypes.func.isRequired,

	// "Snack" hiding CSS animation duration.
	// Is 400 milliseconds by default.
	hideAnimationDuration: PropTypes.number.isRequired,

	// The total display duration (in milliseconds) of a snack
	// is `minTime + message.length * lengthTimeFactor`
	minTime: PropTypes.number.isRequired,
	lengthTimeFactor: PropTypes.number.isRequired
};
Snackbar.defaultProps = {
	hideAnimationDuration: 400,
	minTime: 1200,
	lengthTimeFactor: 60
};
export default Snackbar;
//# sourceMappingURL=Snackbar.js.map