var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import classNames from 'classnames';

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js

var Tooltip = function (_PureComponent) {
	_inherits(Tooltip, _PureComponent);

	function Tooltip() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Tooltip);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.show = function () {
			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (_this.hide_timeout) {
				clearTimeout(_this.hide_timeout);
				_this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				_this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					if (!_this.tooltip) {
						_this.create_tooltip();
					}

					// this.tooltip.style.display = 'block'

					// Play tooltip showing animation
					animate = true;
				}

			var _this$calculate_coord = _this.calculate_coordinates(),
			    x = _this$calculate_coord.x,
			    y = _this$calculate_coord.y;

			_this.tooltip.style.left = x + 'px';
			_this.tooltip.style.top = y + 'px';

			// Play tooltip showing animation
			// (doing it after setting position because
			//  setting position applies `display: block`)
			if (animate) {
				_this.tooltip.classList.add('rrui__tooltip--after-show');
			}
		}, _this.hide = function () {
			var hidingAnimationDuration = _this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.
			// if (this.hide_timeout || this.tooltip.style.display === 'none')

			if (_this.hide_timeout || !_this.tooltip) {
				return;
			}

			// Play tooltip hiding animation
			_this.tooltip.classList.add('rrui__tooltip--before-hide');

			// Set the tooltip to `display: none`
			// after its hiding animation finishes.
			_this.hide_timeout = setTimeout(function () {
				_this.hide_timeout = undefined;
				_this.destroy_tooltip();
				// this.tooltip.style.display = 'none'
				// this.tooltip.classList.remove('rrui__tooltip--before-hide')
				// this.tooltip.classList.remove('rrui__tooltip--after-show')
			}, hidingAnimationDuration);
		}, _this.on_mouse_enter = function () {
			var _this$props = _this.props,
			    text = _this$props.text,
			    content = _this$props.content;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too

			if (_this.mobile) {
				return;
			}

			// If the tooltip has no text then don't show it.
			if (!text && !content) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (_this.show_timeout) {
				return;
			}

			var delay = _this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			_this.show_timeout = setTimeout(function () {
				_this.show_timeout = undefined;
				_this.show();
			}, delay);
		}, _this.on_mouse_leave = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.mobile) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (_this.show_timeout) {
				clearTimeout(_this.show_timeout);
				_this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			_this.hide();
		}, _this.on_touch_start = function () {
			var _this$props2 = _this.props,
			    text = _this$props2.text,
			    content = _this$props2.content;

			// mouse enter events won't be processed from now on

			_this.mobile = true;

			// If the tooltip has no text then don't show it.
			if (!text && !content) {
				return;
			}

			_this.show();
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Tooltip, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(_ref2) {
			var text = _ref2.text,
			    content = _ref2.content;

			// Update tooltip text
			if (this.tooltip && (text !== this.props.text || content !== this.props.content)) {
				this.tooltip.textContent = text || content;
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.show_timeout);
			clearTimeout(this.hide_timeout);

			this.show_timeout = undefined;
			this.hide_timeout = undefined;

			this.destroy_tooltip();
		}
	}, {
		key: 'create_tooltip',
		value: function create_tooltip() {
			var _props = this.props,
			    text = _props.text,
			    content = _props.content,
			    tooltipClassName = _props.tooltipClassName;


			this.tooltip = document.createElement('div');

			// this.tooltip.style.display  = 'none'
			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			this.tooltip.classList.add('rrui__tooltip');

			if (tooltipClassName) {
				this.tooltip.classList.add(tooltipClassName);
			}

			this.tooltip.textContent = text || content;

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'destroy_tooltip',
		value: function destroy_tooltip() {
			if (this.tooltip) {
				// Won't throw an exception
				this.tooltip.parentNode.removeChild(this.tooltip);
				this.tooltip = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			var container = this.props.container;

			return container();
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = ReactDOM.findDOMNode(this.origin);

			var origin_width = origin.offsetWidth;
			// const origin_height = origin.offsetHeight

			var _offset = offset(origin);

			var top = _offset.top - height - offset(this.container()).top;
			var left = _offset.left + origin_width / 2 - width / 2;

			return reposition_within_screen(left, top, width, height);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			var _props2 = this.props,
			    inline = _props2.inline,
			    style = _props2.style,
			    className = _props2.className,
			    children = _props2.children,
			    text = _props2.text,
			    content = _props2.content,
			    delay = _props2.delay,
			    hidingAnimationDuration = _props2.hidingAnimationDuration,
			    container = _props2.container,
			    tooltipClassName = _props2.tooltipClassName,
			    rest = _objectWithoutProperties(_props2, ['inline', 'style', 'className', 'children', 'text', 'content', 'delay', 'hidingAnimationDuration', 'container', 'tooltipClassName']);

			return React.createElement(
				'div',
				_extends({}, rest, {
					ref: function ref(_ref3) {
						return _this2.origin = _ref3;
					},
					onMouseEnter: this.on_mouse_enter,
					onMouseLeave: this.on_mouse_leave,
					onTouchStart: this.on_touch_start,
					onTouchMove: this.hide,
					onTouchEnd: this.hide,
					onTouchCancel: this.hide,
					style: inline ? style ? _extends({}, inline_style, style) : inline_style : style,
					className: classNames('rrui__tooltip__target', className) }),
				children
			);
		}
	}]);

	return Tooltip;
}(PureComponent);

Tooltip.propTypes = {
	// Tooltip text
	text: PropTypes.string,
	content: PropTypes.string,

	// Whether this element should be displayed as `inline-block`.
	// (is `true` by default)
	inline: PropTypes.bool.isRequired,

	// The delay before the tooltip is shown (in milliseconds)
	delay: PropTypes.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: PropTypes.number.isRequired,

	// `container: () => DOMElement` property is optional
	// and is gonna be the parent DOM Element for the tooltip itself
	// (`document.body` by default).
	// (in which case make sure that `document.body` has no `margin`
	//  otherwise tooltip `left` and `top` positions will be slightly off).
	container: PropTypes.func,

	// CSS style object
	style: PropTypes.object,

	// CSS class name
	className: PropTypes.string,

	// Tooltip CSS class name
	tooltipClassName: PropTypes.string
};
Tooltip.defaultProps = {
	inline: true,
	delay: 200, // in milliseconds
	hidingAnimationDuration: 120, // in milliseconds
	container: function container() {
		return document.body;
	}
};
export default Tooltip;


function reposition_within_screen(x, y, width, height) {
	var minimal_margin = 4; // in pixels

	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

// http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function offset(element) {
	var rect = element.getBoundingClientRect();

	var client_left = document.clientLeft || document.body.clientLeft || 0;
	var client_top = document.clientTop || document.body.clientTop || 0;

	var top = rect.top + window.pageYOffset - client_top;
	var left = rect.left + window.pageXOffset - client_left;

	return { top: top, left: left };
}

var inline_style = {
	display: 'inline-block'
};
//# sourceMappingURL=Tooltip.js.map